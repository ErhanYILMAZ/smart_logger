   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "main.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .section .text.XMC_GPIO_SetOutputLow,"ax",%progbits
  20              	 .align 2
  21              	 .thumb
  22              	 .thumb_func
  24              	XMC_GPIO_SetOutputLow:
  25              	.LFB178:
  26              	 .file 1 "C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc/xmc_gpio.h"
   1:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** /**
   2:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @file xmc_gpio.h
   3:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @date 2015-06-20
   4:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
   5:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @cond
   6:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
   7:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * XMClib v2.1.20 - XMC Peripheral Driver Library 
   8:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
   9:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * Copyright (c) 2015-2018, Infineon Technologies AG
  10:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * All rights reserved.                        
  11:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *                                             
  12:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  13:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * following conditions are met:   
  14:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *                                                                              
  15:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * Redistributions of source code must retain the above copyright notice, this list of conditions a
  16:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * disclaimer.                        
  17:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * 
  18:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * Redistributions in binary form must reproduce the above copyright notice, this list of condition
  19:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * disclaimer in the documentation and/or other materials provided with the distribution.          
  20:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * 
  21:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * Neither the name of the copyright holders nor the names of its contributors may be used to endor
  22:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * products derived from this software without specific prior written permission.                  
  23:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *                                                                              
  24:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  25:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  26:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  27:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  28:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  29:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  30:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            
  31:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *                                                                              
  32:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  33:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * Infineon Technologies AG dave@infineon.com).                                                    
  34:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
  35:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  36:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * Change History
  37:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * --------------
  38:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  39:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * 2015-02-20:
  40:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *     - Initial draft<br>
  41:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *     - Documentation improved <br>
  42:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *      
  43:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * 2015-06-20:
  44:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *     - Removed version macros and declaration of GetDriverVersion API
  45:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  46:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @endcond
  47:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  48:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  */
  49:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
  50:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** #ifndef XMC_GPIO_H
  51:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** #define XMC_GPIO_H
  52:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
  53:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
  54:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * HEADER FILES
  55:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
  56:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
  57:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** #include "xmc_common.h"
  58:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
  59:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** /**
  60:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @addtogroup XMClib XMC Peripheral Library
  61:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @{
  62:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  */
  63:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
  64:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** /**
  65:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @addtogroup GPIO
  66:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @brief General Purpose Input Output (GPIO) driver for the XMC microcontroller family.
  67:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  68:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * GPIO driver provide a generic and very flexible software interface for all standard digital I/O 
  69:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * Each port slice has individual interfaces for the operation as General Purpose I/O and it furthe
  70:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * connectivity to the on-chip periphery and the control for the pad characteristics. 
  71:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  72:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * The driver is divided into Input and Output mode.
  73:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  74:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * Input mode features:
  75:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Configuration structure XMC_GPIO_CONFIG_t and initialization function XMC_GPIO_Init()
  76:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of weak pull-up or pull-down device. Configuration structure XMC_GPIO_MO
  77:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * \if XMC1
  78:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of input hysteresis. XMC_GPIO_SetInputHysteresis()
  79:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * \endif
  80:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  81:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * 
  82:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * Output mode features:
  83:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of push pull/open drain and Alternate output. Configuration structure XM
  84:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * \if XMC4
  85:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of pad driver strength. Configuration structure XMC_GPIO_OUTPUT_STRENGTH
  86:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * \endif
  87:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  88:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of initial output level. Configuration structure XMC_GPIO_OUTPUT_LEVEL_t
  89:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  90:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *@{
  91:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  */
  92:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  
  93:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
  94:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * MACROS
  95:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
  96:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
  97:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** #define PORT_IOCR_PC_Pos PORT0_IOCR0_PC0_Pos
  98:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** #define PORT_IOCR_PC_Msk PORT0_IOCR0_PC0_Msk
  99:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 100:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** #define PORT_IOCR_PC_Size 				(8U)
 101:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 											
 102:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 103:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** #define XMC_GPIO_CHECK_OUTPUT_LEVEL(level) ((level == XMC_GPIO_OUTPUT_LEVEL_LOW) || \
 104:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****                                             (level == XMC_GPIO_OUTPUT_LEVEL_HIGH))
 105:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****                                             
 106:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** #define XMC_GPIO_CHECK_HWCTRL(hwctrl) ((hwctrl == XMC_GPIO_HWCTRL_DISABLED) || \
 107:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****                                        (hwctrl == XMC_GPIO_HWCTRL_PERIPHERAL1) || \
 108:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****                                        (hwctrl == XMC_GPIO_HWCTRL_PERIPHERAL2))                    
 109:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****                                             
 110:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
 111:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * ENUMS
 112:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
 113:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 114:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 115:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 116:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * Defines output level of a pin. Use type \a XMC_GPIO_OUTPUT_LEVEL_t for this enum.
 117:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 118:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** typedef enum XMC_GPIO_OUTPUT_LEVEL
 119:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** {
 120:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_OUTPUT_LEVEL_LOW  = 0x10000U, /**<  Reset bit */
 121:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_OUTPUT_LEVEL_HIGH = 0x1U, 	/**< Set bit  */
 122:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** } XMC_GPIO_OUTPUT_LEVEL_t;
 123:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 124:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 125:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * Defines direct hardware control characteristics of the pin . Use type \a XMC_GPIO_HWCTRL_t for t
 126:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 127:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** typedef enum XMC_GPIO_HWCTRL
 128:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** {
 129:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_HWCTRL_DISABLED     = 0x0U, /**<  Software control only */
 130:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_HWCTRL_PERIPHERAL1  = 0x1U, /**<  HWI0/HWO0 control path can override the software confi
 131:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_HWCTRL_PERIPHERAL2  = 0x2U  /**<  HWI1/HWO1 control path can override the software confi
 132:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** } XMC_GPIO_HWCTRL_t;
 133:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 134:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
 135:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * DEVICE FAMILY EXTENSIONS
 136:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
 137:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 138:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  #if UC_FAMILY == XMC1
 139:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** #include "xmc1_gpio.h"
 140:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** #elif UC_FAMILY == XMC4
 141:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** #include "xmc4_gpio.h"
 142:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** #else
 143:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** #error "xmc_gpio.h: family device not supported"
 144:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** #endif
 145:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 146:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
 147:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * API PROTOTYPES
 148:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
 149:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 150:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** #ifdef __cplusplus
 151:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** extern "C" {
 152:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** #endif
 153:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 154:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 155:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 156:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port	  Constant pointer pointing to GPIO port, to access port registers like Pn_OUT,Pn_O
 157:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	  Port pin number.
 158:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  config GPIO configuration data structure. Refer data structure @ref XMC_GPIO_CONFIG_t fo
 159:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 160:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 161:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 162:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 163:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * \if XMC1
 164:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * Initializes input / output mode settings like, pull up / pull down devices,hysteresis, push pull
 165:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * Also configures alternate function outputs and clears hardware port control for a selected \a po
 166:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * \a config provides selected I/O settings. It configures hardware registers Pn_IOCR,Pn_OUT, Pn_OM
 167:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * \endif
 168:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * \if XMC4
 169:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * Initializes input / output mode settings like, pull up / pull down devices,push pull /open drain
 170:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * Also configures alternate function outputs and clears hardware port control for selected \a port
 171:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * It configures hardware registers Pn_IOCR,Pn_OUT,Pn_OMR,Pn_PDISC and Pn_PDR.\n
 172:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * \endif
 173:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 174:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 175:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *  None
 176:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 177:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 178:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * This API is called in definition of DAVE_init by code generation and therefore should not be exp
 179:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * for the normal operation. Use other APIs only after DAVE_init is called successfully (returns DA
 180:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 181:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 182:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 183:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 184:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  
 185:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** void XMC_GPIO_Init(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_CONFIG_t *const c
 186:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  
 187:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 188:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 189:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port	Constant pointer pointing to GPIO port, to access hardware register Pn_IOCR.
 190:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	Port pin number.
 191:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  mode input / output functionality selection. Refer @ref XMC_GPIO_MODE_t for valid values
 192:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 193:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 194:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 195:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 196:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * Sets digital input and output driver functionality and characteristics of a GPIO port pin. It co
 197:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * registers Pn_IOCR. \a mode is initially configured during initialization in XMC_GPIO_Init(). Cal
 198:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * the port direction functionality as needed later in the program.
 199:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 200:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 201:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *  None
 202:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 203:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 204:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 205:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** void XMC_GPIO_SetMode(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_MODE_t mode);
 206:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 207:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 208:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 209:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 210:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port	 Constant pointer pointing to GPIO port, to access hardware register Pn_OMR.
 211:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	 Port pin number.
 212:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  level output level selection. Refer @ref XMC_GPIO_OUTPUT_LEVEL_t for valid values.
 213:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 214:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 215:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 216:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 217:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * Set port pin output level to high or low.It configures hardware registers Pn_OMR.\a level is ini
 218:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * configured during initialization in XMC_GPIO_Init(). Call this API to alter output level as need
 219:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 220:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 221:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *  XMC_GPIO_SetOutputHigh(), XMC_GPIO_SetOutputLow().
 222:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 223:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 224:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to output mode using XMC_GPIO_SetMode().
 225:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 226:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 227:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 228:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 229:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_SetOutputLevel(XMC_GPIO_PORT_t *const port, const uint8_t pin, const 
 230:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** {
 231:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_SetOutputLevel: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
 232:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_SetOutputLevel: Invalid output level", XMC_GPIO_CHECK_OUTPUT_LEVEL(level));
 233:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****   
 234:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****   port->OMR = (uint32_t)level << pin;
 235:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** }
 236:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 237:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 238:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 239:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port constant pointer pointing to GPIO port, to access hardware register Pn_OMR.
 240:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	Port pin number.
 241:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 242:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 243:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 244:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 245:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *  Sets port pin output to high. It configures hardware registers Pn_OMR.
 246:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 247:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *  \par<b>Related APIs:</b><BR>
 248:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *  XMC_GPIO_SetOutputLow()
 249:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 250:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 251:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to output mode using XMC_GPIO_SetMode().\n
 252:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * Register Pn_OMR is virtual and does not contain any flip-flop. A read action delivers the value 
 253:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 254:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 255:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 256:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 257:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** {
 258:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
 259:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 260:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****   port->OMR = (uint32_t)0x1U << pin;
 261:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** }
 262:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 263:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 264:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 265:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port	constant pointer pointing to GPIO port, to access hardware register Pn_OMR.
 266:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	port pin number.
 267:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 268:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return  None
 269:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 270:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *\par<b>Description:</b><br>
 271:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * Sets port pin output to low. It configures hardware registers Pn_OMR.\n
 272:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 273:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>>
 274:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * XMC_GPIO_SetOutputHigh()
 275:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 276:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *\par<b>Note:</b><br>
 277:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to output mode using XMC_GPIO_SetMode().
 278:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * Register Pn_OMR is virtual and does not contain any flip-flop. A read action delivers the value 
 279:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 280:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 281:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 282:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 283:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** {
  27              	 .loc 1 283 0
  28              	 .cfi_startproc
  29              	 
  30              	 
  31              	 
  32 0000 80B4     	 push {r7}
  33              	.LCFI0:
  34              	 .cfi_def_cfa_offset 4
  35              	 .cfi_offset 7,-4
  36 0002 83B0     	 sub sp,sp,#12
  37              	.LCFI1:
  38              	 .cfi_def_cfa_offset 16
  39 0004 00AF     	 add r7,sp,#0
  40              	.LCFI2:
  41              	 .cfi_def_cfa_register 7
  42 0006 7860     	 str r0,[r7,#4]
  43 0008 0B46     	 mov r3,r1
  44 000a FB70     	 strb r3,[r7,#3]
 284:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
 285:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 286:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****   port->OMR = 0x10000U << pin;
  45              	 .loc 1 286 0
  46 000c FB78     	 ldrb r3,[r7,#3]
  47 000e 4FF48032 	 mov r2,#65536
  48 0012 9A40     	 lsls r2,r2,r3
  49 0014 7B68     	 ldr r3,[r7,#4]
  50 0016 5A60     	 str r2,[r3,#4]
 287:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** }
  51              	 .loc 1 287 0
  52 0018 0C37     	 adds r7,r7,#12
  53              	.LCFI3:
  54              	 .cfi_def_cfa_offset 4
  55 001a BD46     	 mov sp,r7
  56              	.LCFI4:
  57              	 .cfi_def_cfa_register 13
  58              	 
  59 001c 5DF8047B 	 ldr r7,[sp],#4
  60              	.LCFI5:
  61              	 .cfi_restore 7
  62              	 .cfi_def_cfa_offset 0
  63 0020 7047     	 bx lr
  64              	 .cfi_endproc
  65              	.LFE178:
  67 0022 00BF     	 .section .text.XMC_GPIO_ToggleOutput,"ax",%progbits
  68              	 .align 2
  69              	 .thumb
  70              	 .thumb_func
  72              	XMC_GPIO_ToggleOutput:
  73              	.LFB179:
 288:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 289:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 290:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 291:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param port constant pointer pointing to GPIO port, to access hardware register Pn_OMR.
 292:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param pin  port pin number.
 293:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 294:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 295:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 296:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 297:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * Configures port pin output to Toggle. It configures hardware registers Pn_OMR.
 298:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 299:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 300:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * XMC_GPIO_SetOutputHigh(), XMC_GPIO_SetOutputLow().
 301:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 302:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 303:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to output mode using XMC_GPIO_SetMode(). Regis
 304:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * and does not contain any flip-flop. A read action delivers the value of 0.
 305:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 306:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 307:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 308:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_ToggleOutput(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 309:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** {
  74              	 .loc 1 309 0
  75              	 .cfi_startproc
  76              	 
  77              	 
  78              	 
  79 0000 80B4     	 push {r7}
  80              	.LCFI6:
  81              	 .cfi_def_cfa_offset 4
  82              	 .cfi_offset 7,-4
  83 0002 83B0     	 sub sp,sp,#12
  84              	.LCFI7:
  85              	 .cfi_def_cfa_offset 16
  86 0004 00AF     	 add r7,sp,#0
  87              	.LCFI8:
  88              	 .cfi_def_cfa_register 7
  89 0006 7860     	 str r0,[r7,#4]
  90 0008 0B46     	 mov r3,r1
  91 000a FB70     	 strb r3,[r7,#3]
 310:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_ToggleOutput: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
 311:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 312:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****   port->OMR = 0x10001U << pin;
  92              	 .loc 1 312 0
  93 000c FB78     	 ldrb r3,[r7,#3]
  94 000e 4FF00112 	 mov r2,#65537
  95 0012 9A40     	 lsls r2,r2,r3
  96 0014 7B68     	 ldr r3,[r7,#4]
  97 0016 5A60     	 str r2,[r3,#4]
 313:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** }
  98              	 .loc 1 313 0
  99 0018 0C37     	 adds r7,r7,#12
 100              	.LCFI9:
 101              	 .cfi_def_cfa_offset 4
 102 001a BD46     	 mov sp,r7
 103              	.LCFI10:
 104              	 .cfi_def_cfa_register 13
 105              	 
 106 001c 5DF8047B 	 ldr r7,[sp],#4
 107              	.LCFI11:
 108              	 .cfi_restore 7
 109              	 .cfi_def_cfa_offset 0
 110 0020 7047     	 bx lr
 111              	 .cfi_endproc
 112              	.LFE179:
 114 0022 00BF     	 .section .text.XMC_GPIO_GetInput,"ax",%progbits
 115              	 .align 2
 116              	 .thumb
 117              	 .thumb_func
 119              	XMC_GPIO_GetInput:
 120              	.LFB180:
 314:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 315:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 316:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 317:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param port constant pointer pointing to GPIO port, to access hardware register Pn_IN.
 318:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param pin  Port pin number.
 319:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 320:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return uint32_t pin logic level status.
 321:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 322:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *\par<b>Description:</b><br>
 323:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * Reads the Pn_IN register and returns the current logical value at the GPIO pin.
 324:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 325:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 326:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * None
 327:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 328:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 329:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to input mode using XMC_GPIO_SetMode().
 330:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 331:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 332:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 333:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** __STATIC_INLINE uint32_t XMC_GPIO_GetInput(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 334:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** {
 121              	 .loc 1 334 0
 122              	 .cfi_startproc
 123              	 
 124              	 
 125              	 
 126 0000 80B4     	 push {r7}
 127              	.LCFI12:
 128              	 .cfi_def_cfa_offset 4
 129              	 .cfi_offset 7,-4
 130 0002 83B0     	 sub sp,sp,#12
 131              	.LCFI13:
 132              	 .cfi_def_cfa_offset 16
 133 0004 00AF     	 add r7,sp,#0
 134              	.LCFI14:
 135              	 .cfi_def_cfa_register 7
 136 0006 7860     	 str r0,[r7,#4]
 137 0008 0B46     	 mov r3,r1
 138 000a FB70     	 strb r3,[r7,#3]
 335:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_GetInput: Invalid port", XMC_GPIO_CHECK_PORT(port));
 336:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** 
 337:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h ****   return (((port->IN) >> pin) & 0x1U);
 139              	 .loc 1 337 0
 140 000c 7B68     	 ldr r3,[r7,#4]
 141 000e 5A6A     	 ldr r2,[r3,#36]
 142 0010 FB78     	 ldrb r3,[r7,#3]
 143 0012 22FA03F3 	 lsr r3,r2,r3
 144 0016 03F00103 	 and r3,r3,#1
 338:C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc\xmc_gpio.h **** }
 145              	 .loc 1 338 0
 146 001a 1846     	 mov r0,r3
 147 001c 0C37     	 adds r7,r7,#12
 148              	.LCFI15:
 149              	 .cfi_def_cfa_offset 4
 150 001e BD46     	 mov sp,r7
 151              	.LCFI16:
 152              	 .cfi_def_cfa_register 13
 153              	 
 154 0020 5DF8047B 	 ldr r7,[sp],#4
 155              	.LCFI17:
 156              	 .cfi_restore 7
 157              	 .cfi_def_cfa_offset 0
 158 0024 7047     	 bx lr
 159              	 .cfi_endproc
 160              	.LFE180:
 162              	 .global dataUpdated
 163 0026 00BF     	 .section .bss.dataUpdated,"aw",%nobits
 166              	dataUpdated:
 167 0000 00       	 .space 1
 168              	 .global cellVoltagesUpdated
 169              	 .section .bss.cellVoltagesUpdated,"aw",%nobits
 172              	cellVoltagesUpdated:
 173 0000 00       	 .space 1
 174              	 .global sampleCounter
 175              	 .section .bss.sampleCounter,"aw",%nobits
 176              	 .align 2
 179              	sampleCounter:
 180 0000 00000000 	 .space 4
 181              	 .comm FatFs,568,4
 182              	 .comm Fil,556,4
 183              	 .comm current_time,8,4
 184              	 .comm set_time,8,4
 185              	 .global setTimeOnProcces
 186              	 .section .bss.setTimeOnProcces,"aw",%nobits
 189              	setTimeOnProcces:
 190 0000 00       	 .space 1
 191              	 .global setTimeMenu
 192              	 .section .bss.setTimeMenu,"aw",%nobits
 195              	setTimeMenu:
 196 0000 00       	 .space 1
 197              	 .global button2Pressed
 198              	 .section .bss.button2Pressed,"aw",%nobits
 201              	button2Pressed:
 202 0000 00       	 .space 1
 203              	 .global state
 204              	 .section .bss.state,"aw",%nobits
 207              	state:
 208 0000 00       	 .space 1
 209              	 .global stateBattVolt
 210              	 .section .bss.stateBattVolt,"aw",%nobits
 213              	stateBattVolt:
 214 0000 00       	 .space 1
 215              	 .global stateModuleTemps
 216              	 .section .bss.stateModuleTemps,"aw",%nobits
 219              	stateModuleTemps:
 220 0000 00       	 .space 1
 221              	 .global stateCellVoltages
 222              	 .section .bss.stateCellVoltages,"aw",%nobits
 225              	stateCellVoltages:
 226 0000 00       	 .space 1
 227              	 .global cellVoltagesFlowCounter
 228              	 .section .bss.cellVoltagesFlowCounter,"aw",%nobits
 231              	cellVoltagesFlowCounter:
 232 0000 00       	 .space 1
 233              	 .global onProcess
 234              	 .section .bss.onProcess,"aw",%nobits
 237              	onProcess:
 238 0000 00       	 .space 1
 239              	 .global samplingTimer
 240              	 .section .bss.samplingTimer,"aw",%nobits
 243              	samplingTimer:
 244 0000 00       	 .space 1
 245              	 .global canTimeoutTimerEnable
 246              	 .section .bss.canTimeoutTimerEnable,"aw",%nobits
 249              	canTimeoutTimerEnable:
 250 0000 00       	 .space 1
 251              	 .global canTimeoutCounter
 252              	 .section .bss.canTimeoutCounter,"aw",%nobits
 255              	canTimeoutCounter:
 256 0000 00       	 .space 1
 257              	 .global flowControl
 258              	 .section .data.flowControl,"aw",%progbits
 259              	 .align 2
 262              	flowControl:
 263 0000 30       	 .byte 48
 264 0001 08       	 .byte 8
 265 0002 14       	 .byte 20
 266 0003 FF       	 .byte -1
 267 0004 FF       	 .byte -1
 268 0005 FF       	 .byte -1
 269 0006 FF       	 .byte -1
 270 0007 FF       	 .byte -1
 271              	 .global reqBattAmp
 272              	 .section .data.reqBattAmp,"aw",%progbits
 273              	 .align 2
 276              	reqBattAmp:
 277 0000 03       	 .byte 3
 278 0001 22       	 .byte 34
 279 0002 02       	 .byte 2
 280 0003 03       	 .byte 3
 281 0004 FF       	 .byte -1
 282 0005 FF       	 .byte -1
 283 0006 FF       	 .byte -1
 284 0007 FF       	 .byte -1
 285              	 .global reqBattVolt
 286              	 .section .data.reqBattVolt,"aw",%progbits
 287              	 .align 2
 290              	reqBattVolt:
 291 0000 03       	 .byte 3
 292 0001 22       	 .byte 34
 293 0002 02       	 .byte 2
 294 0003 04       	 .byte 4
 295 0004 FF       	 .byte -1
 296 0005 FF       	 .byte -1
 297 0006 FF       	 .byte -1
 298 0007 FF       	 .byte -1
 299              	 .global reqModuleTemps
 300              	 .section .data.reqModuleTemps,"aw",%progbits
 301              	 .align 2
 304              	reqModuleTemps:
 305 0000 03       	 .byte 3
 306 0001 22       	 .byte 34
 307 0002 02       	 .byte 2
 308 0003 02       	 .byte 2
 309 0004 FF       	 .byte -1
 310 0005 FF       	 .byte -1
 311 0006 FF       	 .byte -1
 312 0007 FF       	 .byte -1
 313              	 .global reqCellVoltages
 314              	 .section .data.reqCellVoltages,"aw",%progbits
 315              	 .align 2
 318              	reqCellVoltages:
 319 0000 03       	 .byte 3
 320 0001 22       	 .byte 34
 321 0002 02       	 .byte 2
 322 0003 08       	 .byte 8
 323 0004 FF       	 .byte -1
 324 0005 FF       	 .byte -1
 325 0006 FF       	 .byte -1
 326 0007 FF       	 .byte -1
 327              	 .comm smartdata,308,4
 328              	 .section .text.CCU43_1_IRQHandler,"ax",%progbits
 329              	 .align 2
 330              	 .global CCU43_1_IRQHandler
 331              	 .thumb
 332              	 .thumb_func
 334              	CCU43_1_IRQHandler:
 335              	.LFB433:
 336              	 .file 2 "../main.c"
   1:../main.c     **** /**
   2:../main.c     **** * @file main.c
   3:../main.c     **** *
   4:../main.c     **** *  @date 28.2.19
   5:../main.c     **** *  @author Erhan YILMAZ
   6:../main.c     **** *  @brief Smart car OBDII Data logger application.
   7:../main.c     **** *  Based on https://github.com/MyLab-odyssey/ED_BMSdiag
   8:../main.c     **** *  Application code developed and tested on XMC4500 relax kit
   9:../main.c     **** *  Used for Smart EV car communication via OBDII can be evaluate for other usages.
  10:../main.c     **** *  Module codes generated by DAVE APPs. In case of any configuration change DAVE App modules should
  11:../main.c     **** */
  12:../main.c     **** 
  13:../main.c     **** #include <stdio.h>
  14:../main.c     **** #include <math.h>
  15:../main.c     **** 
  16:../main.c     **** #include <DAVE.h>                 //Declarations from DAVE Code Generation (includes SFR declaratio
  17:../main.c     **** #include "deffs.h"
  18:../main.c     **** #include "LCD_I2C.h"
  19:../main.c     **** void UpdateSDCard(void);
  20:../main.c     **** 
  21:../main.c     **** 
  22:../main.c     **** 
  23:../main.c     **** /**
  24:../main.c     **** 
  25:../main.c     ****  * @brief main() - Application entry point
  26:../main.c     ****  *
  27:../main.c     ****  * <b>Details of function</b><br>
  28:../main.c     ****  * This routine is the application entry point. It is invoked by the device startup code. It is res
  29:../main.c     ****  * invoking the APP initialization dispatcher routine - DAVE_Init() and hosting the place-holder fo
  30:../main.c     ****  * code.
  31:../main.c     ****  */
  32:../main.c     **** 
  33:../main.c     **** 
  34:../main.c     **** 
  35:../main.c     **** void TimerIRQHandler(void)
  36:../main.c     **** {
 337              	 .loc 2 36 0
 338              	 .cfi_startproc
 339              	 
 340              	 
 341 0000 80B5     	 push {r7,lr}
 342              	.LCFI18:
 343              	 .cfi_def_cfa_offset 8
 344              	 .cfi_offset 7,-8
 345              	 .cfi_offset 14,-4
 346 0002 00AF     	 add r7,sp,#0
 347              	.LCFI19:
 348              	 .cfi_def_cfa_register 7
  37:../main.c     **** 	if(!onProcess)
 349              	 .loc 2 37 0
 350 0004 274B     	 ldr r3,.L8
 351 0006 1B78     	 ldrb r3,[r3]
 352 0008 002B     	 cmp r3,#0
 353 000a 2CD1     	 bne .L6
  38:../main.c     **** 	{
  39:../main.c     **** 		samplingTimer++;
 354              	 .loc 2 39 0
 355 000c 264B     	 ldr r3,.L8+4
 356 000e 1B78     	 ldrb r3,[r3]
 357 0010 0133     	 adds r3,r3,#1
 358 0012 DAB2     	 uxtb r2,r3
 359 0014 244B     	 ldr r3,.L8+4
 360 0016 1A70     	 strb r2,[r3]
  40:../main.c     **** 		if(samplingTimer >= SAMPLING_PERIOD)
 361              	 .loc 2 40 0
 362 0018 234B     	 ldr r3,.L8+4
 363 001a 1B78     	 ldrb r3,[r3]
 364 001c 002B     	 cmp r3,#0
 365 001e 22D0     	 beq .L6
  41:../main.c     **** 		{
  42:../main.c     **** 
  43:../main.c     **** 
  44:../main.c     **** 			samplingTimer=0;
 366              	 .loc 2 44 0
 367 0020 214B     	 ldr r3,.L8+4
 368 0022 0022     	 movs r2,#0
 369 0024 1A70     	 strb r2,[r3]
  45:../main.c     **** 			CAN_OBDII_LMO_02_Config.mo_ptr->can_identifier = 0x200;
 370              	 .loc 2 45 0
 371 0026 214B     	 ldr r3,.L8+8
 372 0028 1A68     	 ldr r2,[r3]
 373 002a 5368     	 ldr r3,[r2,#4]
 374 002c 4FF40071 	 mov r1,#512
 375 0030 61F31C03 	 bfi r3,r1,#0,#29
 376 0034 5360     	 str r3,[r2,#4]
  46:../main.c     **** 			CAN_OBDII_LMO_02_Config.mo_ptr->can_id_mask = 0x7FF;
 377              	 .loc 2 46 0
 378 0036 1D4B     	 ldr r3,.L8+8
 379 0038 1A68     	 ldr r2,[r3]
 380 003a 9368     	 ldr r3,[r2,#8]
 381 003c 40F2FF71 	 movw r1,#2047
 382 0040 61F31C03 	 bfi r3,r1,#0,#29
 383 0044 9360     	 str r3,[r2,#8]
  47:../main.c     **** 			CAN_OBDII_LMO_02_Config.mo_ptr->can_data_length=8;
 384              	 .loc 2 47 0
 385 0046 194B     	 ldr r3,.L8+8
 386 0048 1B68     	 ldr r3,[r3]
 387 004a 0822     	 movs r2,#8
 388 004c 1A73     	 strb r2,[r3,#12]
  48:../main.c     **** 			CAN_NODE_MO_Init(&CAN_OBDII_LMO_02_Config);
 389              	 .loc 2 48 0
 390 004e 1748     	 ldr r0,.L8+8
 391 0050 FFF7FEFF 	 bl CAN_NODE_MO_Init
  49:../main.c     **** 			state = GET_VELOCITY;
 392              	 .loc 2 49 0
 393 0054 164B     	 ldr r3,.L8+12
 394 0056 0122     	 movs r2,#1
 395 0058 1A70     	 strb r2,[r3]
  50:../main.c     **** 			onProcess = 1;
 396              	 .loc 2 50 0
 397 005a 124B     	 ldr r3,.L8
 398 005c 0122     	 movs r2,#1
 399 005e 1A70     	 strb r2,[r3]
  51:../main.c     **** 			canTimeoutTimerEnable=1;
 400              	 .loc 2 51 0
 401 0060 144B     	 ldr r3,.L8+16
 402 0062 0122     	 movs r2,#1
 403 0064 1A70     	 strb r2,[r3]
 404              	.L6:
  52:../main.c     **** 
  53:../main.c     **** 
  54:../main.c     **** 			/*
  55:../main.c     **** 			samplingTimer=0;
  56:../main.c     **** 			CAN_OBDII_LMO_02_Config.mo_ptr->can_identifier = 0x7ef;
  57:../main.c     **** 			CAN_OBDII_LMO_02_Config.mo_ptr->can_id_mask = 0x7FF;
  58:../main.c     **** 			CAN_OBDII_LMO_02_Config.mo_ptr->can_data_length=8;
  59:../main.c     **** 			CAN_NODE_MO_Init(&CAN_OBDII_LMO_02_Config);
  60:../main.c     **** 			CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,reqBattAmp);
  61:../main.c     **** 			CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
  62:../main.c     **** 			state = GET_BATT_AMP;
  63:../main.c     **** 			onProcess = 1;
  64:../main.c     **** 			canTimeoutTimerEnable=1;
  65:../main.c     **** 			*/
  66:../main.c     **** 
  67:../main.c     **** 		}
  68:../main.c     **** 	}
  69:../main.c     **** 
  70:../main.c     **** 	if(canTimeoutTimerEnable==1)
 405              	 .loc 2 70 0
 406 0066 134B     	 ldr r3,.L8+16
 407 0068 1B78     	 ldrb r3,[r3]
 408 006a 012B     	 cmp r3,#1
 409 006c 19D1     	 bne .L5
  71:../main.c     **** 	{
  72:../main.c     **** 		if(++canTimeoutCounter>=CAN_TIMEOUT)
 410              	 .loc 2 72 0
 411 006e 124B     	 ldr r3,.L8+20
 412 0070 1B78     	 ldrb r3,[r3]
 413 0072 0133     	 adds r3,r3,#1
 414 0074 DAB2     	 uxtb r2,r3
 415 0076 104B     	 ldr r3,.L8+20
 416 0078 1A70     	 strb r2,[r3]
 417 007a 0F4B     	 ldr r3,.L8+20
 418 007c 1B78     	 ldrb r3,[r3]
 419 007e 042B     	 cmp r3,#4
 420 0080 0FD9     	 bls .L5
  73:../main.c     **** 		{
  74:../main.c     **** 			canTimeoutCounter=0;
 421              	 .loc 2 74 0
 422 0082 0D4B     	 ldr r3,.L8+20
 423 0084 0022     	 movs r2,#0
 424 0086 1A70     	 strb r2,[r3]
  75:../main.c     **** 			state=IDLE;
 425              	 .loc 2 75 0
 426 0088 094B     	 ldr r3,.L8+12
 427 008a 0022     	 movs r2,#0
 428 008c 1A70     	 strb r2,[r3]
  76:../main.c     **** 			samplingTimer=0;
 429              	 .loc 2 76 0
 430 008e 064B     	 ldr r3,.L8+4
 431 0090 0022     	 movs r2,#0
 432 0092 1A70     	 strb r2,[r3]
  77:../main.c     **** 			onProcess=0;
 433              	 .loc 2 77 0
 434 0094 034B     	 ldr r3,.L8
 435 0096 0022     	 movs r2,#0
 436 0098 1A70     	 strb r2,[r3]
  78:../main.c     **** 			XMC_GPIO_ToggleOutput(LED1);
 437              	 .loc 2 78 0
 438 009a 0848     	 ldr r0,.L8+24
 439 009c 0121     	 movs r1,#1
 440 009e FFF7FEFF 	 bl XMC_GPIO_ToggleOutput
 441              	.L5:
  79:../main.c     **** 		}
  80:../main.c     **** 	}
  81:../main.c     **** 
  82:../main.c     **** }
 442              	 .loc 2 82 0
 443 00a2 80BD     	 pop {r7,pc}
 444              	.L9:
 445              	 .align 2
 446              	.L8:
 447 00a4 00000000 	 .word onProcess
 448 00a8 00000000 	 .word samplingTimer
 449 00ac 00000000 	 .word CAN_OBDII_LMO_02_Config
 450 00b0 00000000 	 .word state
 451 00b4 00000000 	 .word canTimeoutTimerEnable
 452 00b8 00000000 	 .word canTimeoutCounter
 453 00bc 00810248 	 .word 1208123648
 454              	 .cfi_endproc
 455              	.LFE433:
 457              	 .global __aeabi_i2d
 458              	 .global __aeabi_ddiv
 459              	 .global __aeabi_d2f
 460              	 .section .text.CAN0_1_IRQHandler,"ax",%progbits
 461              	 .align 2
 462              	 .global CAN0_1_IRQHandler
 463              	 .thumb
 464              	 .thumb_func
 466              	CAN0_1_IRQHandler:
 467              	.LFB434:
  83:../main.c     **** 
  84:../main.c     **** void CanM02RxRQHandler_2(void)
  85:../main.c     **** {
 468              	 .loc 2 85 0
 469              	 .cfi_startproc
 470              	 
 471              	 
 472 0000 80B5     	 push {r7,lr}
 473              	.LCFI20:
 474              	 .cfi_def_cfa_offset 8
 475              	 .cfi_offset 7,-8
 476              	 .cfi_offset 14,-4
 477 0002 00AF     	 add r7,sp,#0
 478              	.LCFI21:
 479              	 .cfi_def_cfa_register 7
  86:../main.c     **** 	CAN_NODE_MO_Receive(CAN_OBDII.lmobj_ptr[2]);		// get the received pacakge into message object.
 480              	 .loc 2 86 0
 481 0004 164B     	 ldr r3,.L12
 482 0006 5B69     	 ldr r3,[r3,#20]
 483 0008 1846     	 mov r0,r3
 484 000a FFF7FEFF 	 bl CAN_NODE_MO_Receive
  87:../main.c     **** 	if(CAN_OBDII_LMO_03_Config.mo_ptr->can_identifier == 0x2D5)
 485              	 .loc 2 87 0
 486 000e 154B     	 ldr r3,.L12+4
 487 0010 1B68     	 ldr r3,[r3]
 488 0012 5B68     	 ldr r3,[r3,#4]
 489 0014 23F06043 	 bic r3,r3,#-536870912
 490 0018 40F2D522 	 movw r2,#725
 491 001c 9342     	 cmp r3,r2
 492 001e 1ED1     	 bne .L10
  88:../main.c     **** 	{
  89:../main.c     **** 		smartdata.bms = ((CAN_OBDII_LMO_03_Config.mo_ptr->can_data_byte[4] & 0x03) * 256 + CAN_OBDII_LMO_
 493              	 .loc 2 89 0
 494 0020 104B     	 ldr r3,.L12+4
 495 0022 1B68     	 ldr r3,[r3]
 496 0024 1B7D     	 ldrb r3,[r3,#20]
 497 0026 03F00303 	 and r3,r3,#3
 498 002a 1B02     	 lsls r3,r3,#8
 499 002c 0D4A     	 ldr r2,.L12+4
 500 002e 1268     	 ldr r2,[r2]
 501 0030 527D     	 ldrb r2,[r2,#21]
 502 0032 1344     	 add r3,r3,r2
 503 0034 1846     	 mov r0,r3
 504 0036 FFF7FEFF 	 bl __aeabi_i2d
 505 003a 0246     	 mov r2,r0
 506 003c 0B46     	 mov r3,r1
 507 003e 1046     	 mov r0,r2
 508 0040 1946     	 mov r1,r3
 509 0042 4FF00002 	 mov r2,#0
 510 0046 084B     	 ldr r3,.L12+8
 511 0048 FFF7FEFF 	 bl __aeabi_ddiv
 512 004c 0246     	 mov r2,r0
 513 004e 0B46     	 mov r3,r1
 514 0050 1046     	 mov r0,r2
 515 0052 1946     	 mov r1,r3
 516 0054 FFF7FEFF 	 bl __aeabi_d2f
 517 0058 0246     	 mov r2,r0
 518 005a 044B     	 ldr r3,.L12+12
 519 005c 5A61     	 str r2,[r3,#20]
 520              	.L10:
  90:../main.c     **** 	}
  91:../main.c     **** }
 521              	 .loc 2 91 0
 522 005e 80BD     	 pop {r7,pc}
 523              	.L13:
 524              	 .align 2
 525              	.L12:
 526 0060 00000000 	 .word CAN_OBDII
 527 0064 00000000 	 .word CAN_OBDII_LMO_03_Config
 528 0068 00002440 	 .word 1076101120
 529 006c 00000000 	 .word smartdata
 530              	 .cfi_endproc
 531              	.LFE434:
 533              	 .section .text.CAN0_0_IRQHandler,"ax",%progbits
 534              	 .align 2
 535              	 .global CAN0_0_IRQHandler
 536              	 .thumb
 537              	 .thumb_func
 539              	CAN0_0_IRQHandler:
 540              	.LFB435:
  92:../main.c     **** 
  93:../main.c     **** 
  94:../main.c     **** 
  95:../main.c     **** void CanM02RxRQHandler(void)
  96:../main.c     **** {
 541              	 .loc 2 96 0
 542              	 .cfi_startproc
 543              	 
 544              	 
 545 0000 80B5     	 push {r7,lr}
 546              	.LCFI22:
 547              	 .cfi_def_cfa_offset 8
 548              	 .cfi_offset 7,-8
 549              	 .cfi_offset 14,-4
 550 0002 82B0     	 sub sp,sp,#8
 551              	.LCFI23:
 552              	 .cfi_def_cfa_offset 16
 553 0004 00AF     	 add r7,sp,#0
 554              	.LCFI24:
 555              	 .cfi_def_cfa_register 7
  97:../main.c     **** 
  98:../main.c     **** 	CAN_NODE_MO_Receive(CAN_OBDII.lmobj_ptr[1]);		// get the received pacakge into message object.
 556              	 .loc 2 98 0
 557 0006 A44B     	 ldr r3,.L66
 558 0008 1B69     	 ldr r3,[r3,#16]
 559 000a 1846     	 mov r0,r3
 560 000c FFF7FEFF 	 bl CAN_NODE_MO_Receive
  99:../main.c     **** 	canTimeoutCounter=0;
 561              	 .loc 2 99 0
 562 0010 A24B     	 ldr r3,.L66+4
 563 0012 0022     	 movs r2,#0
 564 0014 1A70     	 strb r2,[r3]
 100:../main.c     **** 
 101:../main.c     **** 	switch(state)
 565              	 .loc 2 101 0
 566 0016 A24B     	 ldr r3,.L66+8
 567 0018 1B78     	 ldrb r3,[r3]
 568 001a 052B     	 cmp r3,#5
 569 001c 00F2A582 	 bhi .L14
 570 0020 01A2     	 adr r2,.L17
 571 0022 52F823F0 	 ldr pc,[r2,r3,lsl#2]
 572 0026 00BF     	 .p2align 2
 573              	.L17:
 574 0028 6B050000 	 .word .L14+1
 575 002c 41000000 	 .word .L18+1
 576 0030 C5000000 	 .word .L19+1
 577 0034 35010000 	 .word .L20+1
 578 0038 E5010000 	 .word .L21+1
 579 003c 15040000 	 .word .L22+1
 580              	 .p2align 1
 581              	.L18:
 102:../main.c     **** 	{
 103:../main.c     **** 		case IDLE:
 104:../main.c     **** 		break;
 105:../main.c     **** 
 106:../main.c     **** 		case GET_VELOCITY:
 107:../main.c     **** 			if(CAN_OBDII_LMO_02_Config.mo_ptr->can_identifier == 0x200)
 582              	 .loc 2 107 0
 583 0040 984B     	 ldr r3,.L66+12
 584 0042 1B68     	 ldr r3,[r3]
 585 0044 5B68     	 ldr r3,[r3,#4]
 586 0046 23F06043 	 bic r3,r3,#-536870912
 587 004a B3F5007F 	 cmp r3,#512
 588 004e 32D1     	 bne .L23
 108:../main.c     **** 			{
 109:../main.c     **** 				smartdata.velocitiy = (CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[2] * 256 + CAN_OBDII_LMO_0
 589              	 .loc 2 109 0
 590 0050 944B     	 ldr r3,.L66+12
 591 0052 1B68     	 ldr r3,[r3]
 592 0054 9B7C     	 ldrb r3,[r3,#18]
 593 0056 1B02     	 lsls r3,r3,#8
 594 0058 924A     	 ldr r2,.L66+12
 595 005a 1268     	 ldr r2,[r2]
 596 005c D27C     	 ldrb r2,[r2,#19]
 597 005e 1344     	 add r3,r3,r2
 598 0060 914A     	 ldr r2,.L66+16
 599 0062 82FB0312 	 smull r1,r2,r2,r3
 600 0066 9210     	 asrs r2,r2,#2
 601 0068 DB17     	 asrs r3,r3,#31
 602 006a D31A     	 subs r3,r2,r3
 603 006c 9AB2     	 uxth r2,r3
 604 006e 8F4B     	 ldr r3,.L66+20
 605 0070 1A80     	 strh r2,[r3]
 110:../main.c     **** 				CAN_OBDII_LMO_02_Config.mo_ptr->can_identifier = 0x7EF;
 606              	 .loc 2 110 0
 607 0072 8C4B     	 ldr r3,.L66+12
 608 0074 1A68     	 ldr r2,[r3]
 609 0076 5368     	 ldr r3,[r2,#4]
 610 0078 40F2EF71 	 movw r1,#2031
 611 007c 61F31C03 	 bfi r3,r1,#0,#29
 612 0080 5360     	 str r3,[r2,#4]
 111:../main.c     **** 				CAN_OBDII_LMO_02_Config.mo_ptr->can_id_mask = 0x7FF;
 613              	 .loc 2 111 0
 614 0082 884B     	 ldr r3,.L66+12
 615 0084 1A68     	 ldr r2,[r3]
 616 0086 9368     	 ldr r3,[r2,#8]
 617 0088 40F2FF71 	 movw r1,#2047
 618 008c 61F31C03 	 bfi r3,r1,#0,#29
 619 0090 9360     	 str r3,[r2,#8]
 112:../main.c     **** 				CAN_OBDII_LMO_02_Config.mo_ptr->can_data_length=8;
 620              	 .loc 2 112 0
 621 0092 844B     	 ldr r3,.L66+12
 622 0094 1B68     	 ldr r3,[r3]
 623 0096 0822     	 movs r2,#8
 624 0098 1A73     	 strb r2,[r3,#12]
 113:../main.c     **** 				CAN_NODE_MO_Init(&CAN_OBDII_LMO_02_Config);
 625              	 .loc 2 113 0
 626 009a 8248     	 ldr r0,.L66+12
 627 009c FFF7FEFF 	 bl CAN_NODE_MO_Init
 114:../main.c     **** 				CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,reqBattAmp);
 628              	 .loc 2 114 0
 629 00a0 8348     	 ldr r0,.L66+24
 630 00a2 8449     	 ldr r1,.L66+28
 631 00a4 FFF7FEFF 	 bl CAN_NODE_MO_UpdateData
 115:../main.c     **** 				CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
 632              	 .loc 2 115 0
 633 00a8 8148     	 ldr r0,.L66+24
 634 00aa FFF7FEFF 	 bl CAN_NODE_MO_Transmit
 116:../main.c     **** 				state = GET_BATT_AMP;
 635              	 .loc 2 116 0
 636 00ae 7C4B     	 ldr r3,.L66+8
 637 00b0 0222     	 movs r2,#2
 638 00b2 1A70     	 strb r2,[r3]
 117:../main.c     **** 			}
 118:../main.c     **** 			else
 119:../main.c     **** 			{
 120:../main.c     **** 				state = IDLE;
 121:../main.c     **** 				onProcess = 0;
 122:../main.c     **** 			}
 123:../main.c     **** 		break;
 639              	 .loc 2 123 0
 640 00b4 59E2     	 b .L14
 641              	.L23:
 120:../main.c     **** 				onProcess = 0;
 642              	 .loc 2 120 0
 643 00b6 7A4B     	 ldr r3,.L66+8
 644 00b8 0022     	 movs r2,#0
 645 00ba 1A70     	 strb r2,[r3]
 121:../main.c     **** 			}
 646              	 .loc 2 121 0
 647 00bc 7E4B     	 ldr r3,.L66+32
 648 00be 0022     	 movs r2,#0
 649 00c0 1A70     	 strb r2,[r3]
 650              	 .loc 2 123 0
 651 00c2 52E2     	 b .L14
 652              	.L19:
 124:../main.c     **** 
 125:../main.c     **** 		case GET_BATT_AMP:
 126:../main.c     **** 			if(CAN_OBDII_LMO_02_Config.mo_ptr->can_identifier == 0x7EF)
 653              	 .loc 2 126 0
 654 00c4 774B     	 ldr r3,.L66+12
 655 00c6 1B68     	 ldr r3,[r3]
 656 00c8 5B68     	 ldr r3,[r3,#4]
 657 00ca 23F06043 	 bic r3,r3,#-536870912
 658 00ce 40F2EF72 	 movw r2,#2031
 659 00d2 9342     	 cmp r3,r2
 660 00d4 26D1     	 bne .L25
 127:../main.c     **** 			{
 128:../main.c     **** 				smartdata.battAmp = (float)((int16_t)(CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[4] * 256 + 
 661              	 .loc 2 128 0
 662 00d6 734B     	 ldr r3,.L66+12
 663 00d8 1B68     	 ldr r3,[r3]
 664 00da 1B7D     	 ldrb r3,[r3,#20]
 665 00dc 9BB2     	 uxth r3,r3
 666 00de 1B02     	 lsls r3,r3,#8
 667 00e0 9AB2     	 uxth r2,r3
 668 00e2 704B     	 ldr r3,.L66+12
 669 00e4 1B68     	 ldr r3,[r3]
 670 00e6 5B7D     	 ldrb r3,[r3,#21]
 671 00e8 9BB2     	 uxth r3,r3
 672 00ea 1344     	 add r3,r3,r2
 673 00ec 9BB2     	 uxth r3,r3
 674 00ee 9BB2     	 uxth r3,r3
 675 00f0 1BB2     	 sxth r3,r3
 676 00f2 07EE903A 	 fmsr s15,r3
 677 00f6 F8EEE77A 	 fsitos s15,s15
 678 00fa 9FED707A 	 flds s14,.L66+36
 679 00fe C7EE877A 	 fdivs s15,s15,s14
 680 0102 6A4B     	 ldr r3,.L66+20
 681 0104 C3ED017A 	 fsts s15,[r3,#4]
 129:../main.c     **** 				CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,reqBattVolt);
 682              	 .loc 2 129 0
 683 0108 6948     	 ldr r0,.L66+24
 684 010a 6D49     	 ldr r1,.L66+40
 685 010c FFF7FEFF 	 bl CAN_NODE_MO_UpdateData
 130:../main.c     **** 				CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
 686              	 .loc 2 130 0
 687 0110 6748     	 ldr r0,.L66+24
 688 0112 FFF7FEFF 	 bl CAN_NODE_MO_Transmit
 131:../main.c     **** 				state = GET_BATT_VOLTAGE;
 689              	 .loc 2 131 0
 690 0116 624B     	 ldr r3,.L66+8
 691 0118 0322     	 movs r2,#3
 692 011a 1A70     	 strb r2,[r3]
 132:../main.c     **** 				stateBattVolt = BATT_VOLT_REQ_RESPONSE;
 693              	 .loc 2 132 0
 694 011c 694B     	 ldr r3,.L66+44
 695 011e 0122     	 movs r2,#1
 696 0120 1A70     	 strb r2,[r3]
 133:../main.c     **** 			}
 134:../main.c     **** 			else
 135:../main.c     **** 			{
 136:../main.c     **** 				CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,reqBattAmp);
 137:../main.c     **** 				CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
 138:../main.c     **** 			}
 139:../main.c     **** 		break;
 697              	 .loc 2 139 0
 698 0122 22E2     	 b .L14
 699              	.L25:
 136:../main.c     **** 				CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
 700              	 .loc 2 136 0
 701 0124 6248     	 ldr r0,.L66+24
 702 0126 6349     	 ldr r1,.L66+28
 703 0128 FFF7FEFF 	 bl CAN_NODE_MO_UpdateData
 137:../main.c     **** 			}
 704              	 .loc 2 137 0
 705 012c 6048     	 ldr r0,.L66+24
 706 012e FFF7FEFF 	 bl CAN_NODE_MO_Transmit
 707              	 .loc 2 139 0
 708 0132 1AE2     	 b .L14
 709              	.L20:
 140:../main.c     **** 
 141:../main.c     **** 		case GET_BATT_VOLTAGE:
 142:../main.c     **** 			switch(stateBattVolt)
 710              	 .loc 2 142 0
 711 0134 634B     	 ldr r3,.L66+44
 712 0136 1B78     	 ldrb r3,[r3]
 713 0138 012B     	 cmp r3,#1
 714 013a 02D0     	 beq .L28
 715 013c 022B     	 cmp r3,#2
 716 013e 18D0     	 beq .L29
 717 0140 48E0     	 b .L62
 718              	.L28:
 143:../main.c     **** 			{
 144:../main.c     **** 				case BATT_VOLT_REQ_RESPONSE:
 145:../main.c     **** 					if(CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[2] == 0x62)
 719              	 .loc 2 145 0
 720 0142 584B     	 ldr r3,.L66+12
 721 0144 1B68     	 ldr r3,[r3]
 722 0146 9B7C     	 ldrb r3,[r3,#18]
 723 0148 622B     	 cmp r3,#98
 724 014a 0AD1     	 bne .L30
 146:../main.c     **** 					{
 147:../main.c     **** 						CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,flowControl);
 725              	 .loc 2 147 0
 726 014c 5848     	 ldr r0,.L66+24
 727 014e 5E49     	 ldr r1,.L66+48
 728 0150 FFF7FEFF 	 bl CAN_NODE_MO_UpdateData
 148:../main.c     **** 						CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
 729              	 .loc 2 148 0
 730 0154 5648     	 ldr r0,.L66+24
 731 0156 FFF7FEFF 	 bl CAN_NODE_MO_Transmit
 149:../main.c     **** 						stateBattVolt = BATT_VOLT_FLOW_RESPONSE;
 732              	 .loc 2 149 0
 733 015a 5A4B     	 ldr r3,.L66+44
 734 015c 0222     	 movs r2,#2
 735 015e 1A70     	 strb r2,[r3]
 150:../main.c     **** 					}
 151:../main.c     **** 					else
 152:../main.c     **** 					{
 153:../main.c     **** 						CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,reqBattVolt);
 154:../main.c     **** 						CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
 155:../main.c     **** 					}
 156:../main.c     **** 				break;
 736              	 .loc 2 156 0
 737 0160 3FE0     	 b .L32
 738              	.L30:
 153:../main.c     **** 						CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
 739              	 .loc 2 153 0
 740 0162 5348     	 ldr r0,.L66+24
 741 0164 5649     	 ldr r1,.L66+40
 742 0166 FFF7FEFF 	 bl CAN_NODE_MO_UpdateData
 154:../main.c     **** 					}
 743              	 .loc 2 154 0
 744 016a 5148     	 ldr r0,.L66+24
 745 016c FFF7FEFF 	 bl CAN_NODE_MO_Transmit
 746              	 .loc 2 156 0
 747 0170 37E0     	 b .L32
 748              	.L29:
 157:../main.c     **** 
 158:../main.c     **** 				case BATT_VOLT_FLOW_RESPONSE:
 159:../main.c     **** 					if(CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[0] == 0x21)
 749              	 .loc 2 159 0
 750 0172 4C4B     	 ldr r3,.L66+12
 751 0174 1B68     	 ldr r3,[r3]
 752 0176 1B7C     	 ldrb r3,[r3,#16]
 753 0178 212B     	 cmp r3,#33
 754 017a 20D1     	 bne .L33
 160:../main.c     **** 					{
 161:../main.c     **** 						smartdata.battVolt = (float)((CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[6] * 256 + CAN_OB
 755              	 .loc 2 161 0
 756 017c 494B     	 ldr r3,.L66+12
 757 017e 1B68     	 ldr r3,[r3]
 758 0180 9B7D     	 ldrb r3,[r3,#22]
 759 0182 1B02     	 lsls r3,r3,#8
 760 0184 474A     	 ldr r2,.L66+12
 761 0186 1268     	 ldr r2,[r2]
 762 0188 D27D     	 ldrb r2,[r2,#23]
 763 018a 1344     	 add r3,r3,r2
 764 018c 07EE903A 	 fmsr s15,r3
 765 0190 F8EEE77A 	 fsitos s15,s15
 766 0194 9FED4D7A 	 flds s14,.L66+52
 767 0198 C7EE877A 	 fdivs s15,s15,s14
 768 019c 434B     	 ldr r3,.L66+20
 769 019e C3ED027A 	 fsts s15,[r3,#8]
 162:../main.c     **** 						CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,reqModuleTemps);
 770              	 .loc 2 162 0
 771 01a2 4348     	 ldr r0,.L66+24
 772 01a4 4A49     	 ldr r1,.L66+56
 773 01a6 FFF7FEFF 	 bl CAN_NODE_MO_UpdateData
 163:../main.c     **** 						CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
 774              	 .loc 2 163 0
 775 01aa 4148     	 ldr r0,.L66+24
 776 01ac FFF7FEFF 	 bl CAN_NODE_MO_Transmit
 164:../main.c     **** 						state = GET_MODULE_TEMPS;
 777              	 .loc 2 164 0
 778 01b0 3B4B     	 ldr r3,.L66+8
 779 01b2 0422     	 movs r2,#4
 780 01b4 1A70     	 strb r2,[r3]
 165:../main.c     **** 						stateModuleTemps = MODULE_TEMPS_REQ_RESPONSE;
 781              	 .loc 2 165 0
 782 01b6 474B     	 ldr r3,.L66+60
 783 01b8 0122     	 movs r2,#1
 784 01ba 1A70     	 strb r2,[r3]
 166:../main.c     **** 					}
 167:../main.c     **** 					else
 168:../main.c     **** 					{
 169:../main.c     **** 						CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,reqBattVolt);
 170:../main.c     **** 						CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
 171:../main.c     **** 						stateBattVolt = BATT_VOLT_REQ_RESPONSE;
 172:../main.c     **** 					}
 173:../main.c     **** 				break;
 785              	 .loc 2 173 0
 786 01bc 11E0     	 b .L32
 787              	.L33:
 169:../main.c     **** 						CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
 788              	 .loc 2 169 0
 789 01be 3C48     	 ldr r0,.L66+24
 790 01c0 3F49     	 ldr r1,.L66+40
 791 01c2 FFF7FEFF 	 bl CAN_NODE_MO_UpdateData
 170:../main.c     **** 						stateBattVolt = BATT_VOLT_REQ_RESPONSE;
 792              	 .loc 2 170 0
 793 01c6 3A48     	 ldr r0,.L66+24
 794 01c8 FFF7FEFF 	 bl CAN_NODE_MO_Transmit
 171:../main.c     **** 					}
 795              	 .loc 2 171 0
 796 01cc 3D4B     	 ldr r3,.L66+44
 797 01ce 0122     	 movs r2,#1
 798 01d0 1A70     	 strb r2,[r3]
 799              	 .loc 2 173 0
 800 01d2 06E0     	 b .L32
 801              	.L62:
 174:../main.c     **** 
 175:../main.c     **** 				default:
 176:../main.c     **** 				case BATT_VOLT_IDLE:
 177:../main.c     **** 					onProcess=0;
 802              	 .loc 2 177 0
 803 01d4 384B     	 ldr r3,.L66+32
 804 01d6 0022     	 movs r2,#0
 805 01d8 1A70     	 strb r2,[r3]
 178:../main.c     **** 					state=IDLE;
 806              	 .loc 2 178 0
 807 01da 314B     	 ldr r3,.L66+8
 808 01dc 0022     	 movs r2,#0
 809 01de 1A70     	 strb r2,[r3]
 179:../main.c     **** 				break;
 810              	 .loc 2 179 0
 811 01e0 00BF     	 nop
 812              	.L32:
 180:../main.c     **** 			}
 181:../main.c     **** 		break;
 813              	 .loc 2 181 0 discriminator 1
 814 01e2 C2E1     	 b .L14
 815              	.L21:
 182:../main.c     **** 
 183:../main.c     **** 		case GET_MODULE_TEMPS:
 184:../main.c     **** 
 185:../main.c     **** 			switch(stateModuleTemps)
 816              	 .loc 2 185 0
 817 01e4 3B4B     	 ldr r3,.L66+60
 818 01e6 1B78     	 ldrb r3,[r3]
 819 01e8 012B     	 cmp r3,#1
 820 01ea 02D0     	 beq .L36
 821 01ec 022B     	 cmp r3,#2
 822 01ee 27D0     	 beq .L37
 823 01f0 08E1     	 b .L63
 824              	.L36:
 186:../main.c     **** 			{
 187:../main.c     **** 				case MODULE_TEMPS_REQ_RESPONSE:
 188:../main.c     **** 					if(CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[2] == 0x62)
 825              	 .loc 2 188 0
 826 01f2 2C4B     	 ldr r3,.L66+12
 827 01f4 1B68     	 ldr r3,[r3]
 828 01f6 9B7C     	 ldrb r3,[r3,#18]
 829 01f8 622B     	 cmp r3,#98
 830 01fa 19D1     	 bne .L38
 189:../main.c     **** 					{
 190:../main.c     **** 						smartdata.tempRawBytes[0]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[6];
 831              	 .loc 2 190 0
 832 01fc 294B     	 ldr r3,.L66+12
 833 01fe 1B68     	 ldr r3,[r3]
 834 0200 9A7D     	 ldrb r2,[r3,#22]
 835 0202 2A4B     	 ldr r3,.L66+20
 836 0204 1A76     	 strb r2,[r3,#24]
 191:../main.c     **** 						smartdata.tempRawBytes[1]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[5];
 837              	 .loc 2 191 0
 838 0206 274B     	 ldr r3,.L66+12
 839 0208 1B68     	 ldr r3,[r3]
 840 020a 5A7D     	 ldrb r2,[r3,#21]
 841 020c 274B     	 ldr r3,.L66+20
 842 020e 5A76     	 strb r2,[r3,#25]
 192:../main.c     **** 						smartdata.tempRawBytes[3]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[7];
 843              	 .loc 2 192 0
 844 0210 244B     	 ldr r3,.L66+12
 845 0212 1B68     	 ldr r3,[r3]
 846 0214 DA7D     	 ldrb r2,[r3,#23]
 847 0216 254B     	 ldr r3,.L66+20
 848 0218 DA76     	 strb r2,[r3,#27]
 193:../main.c     **** 						CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,flowControl);
 849              	 .loc 2 193 0
 850 021a 2548     	 ldr r0,.L66+24
 851 021c 2A49     	 ldr r1,.L66+48
 852 021e FFF7FEFF 	 bl CAN_NODE_MO_UpdateData
 194:../main.c     **** 						CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
 853              	 .loc 2 194 0
 854 0222 2348     	 ldr r0,.L66+24
 855 0224 FFF7FEFF 	 bl CAN_NODE_MO_Transmit
 195:../main.c     **** 						stateModuleTemps = MODULE_TEMPS_FLOW_RESPONSE;
 856              	 .loc 2 195 0
 857 0228 2A4B     	 ldr r3,.L66+60
 858 022a 0222     	 movs r2,#2
 859 022c 1A70     	 strb r2,[r3]
 196:../main.c     **** 					}
 197:../main.c     **** 					else
 198:../main.c     **** 					{
 199:../main.c     **** 						CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,reqModuleTemps);
 200:../main.c     **** 						CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
 201:../main.c     **** 					}
 202:../main.c     **** 				break;
 860              	 .loc 2 202 0
 861 022e F0E0     	 b .L40
 862              	.L38:
 199:../main.c     **** 						CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
 863              	 .loc 2 199 0
 864 0230 1F48     	 ldr r0,.L66+24
 865 0232 2749     	 ldr r1,.L66+56
 866 0234 FFF7FEFF 	 bl CAN_NODE_MO_UpdateData
 200:../main.c     **** 					}
 867              	 .loc 2 200 0
 868 0238 1D48     	 ldr r0,.L66+24
 869 023a FFF7FEFF 	 bl CAN_NODE_MO_Transmit
 870              	 .loc 2 202 0
 871 023e E8E0     	 b .L40
 872              	.L37:
 203:../main.c     **** 
 204:../main.c     **** 				case MODULE_TEMPS_FLOW_RESPONSE:
 205:../main.c     **** 
 206:../main.c     **** 					if(CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[0] == 0x21)
 873              	 .loc 2 206 0
 874 0240 184B     	 ldr r3,.L66+12
 875 0242 1B68     	 ldr r3,[r3]
 876 0244 1B7C     	 ldrb r3,[r3,#16]
 877 0246 212B     	 cmp r3,#33
 878 0248 46D1     	 bne .L41
 207:../main.c     **** 					{
 208:../main.c     **** 						smartdata.tempRawBytes[2]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[1];
 879              	 .loc 2 208 0
 880 024a 164B     	 ldr r3,.L66+12
 881 024c 1B68     	 ldr r3,[r3]
 882 024e 5A7C     	 ldrb r2,[r3,#17]
 883 0250 164B     	 ldr r3,.L66+20
 884 0252 9A76     	 strb r2,[r3,#26]
 209:../main.c     **** 						smartdata.tempRawBytes[4]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[3];
 885              	 .loc 2 209 0
 886 0254 134B     	 ldr r3,.L66+12
 887 0256 1B68     	 ldr r3,[r3]
 888 0258 DA7C     	 ldrb r2,[r3,#19]
 889 025a 144B     	 ldr r3,.L66+20
 890 025c 1A77     	 strb r2,[r3,#28]
 210:../main.c     **** 						smartdata.tempRawBytes[5]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[2];
 891              	 .loc 2 210 0
 892 025e 114B     	 ldr r3,.L66+12
 893 0260 1B68     	 ldr r3,[r3]
 894 0262 9A7C     	 ldrb r2,[r3,#18]
 895 0264 114B     	 ldr r3,.L66+20
 896 0266 5A77     	 strb r2,[r3,#29]
 211:../main.c     **** 						smartdata.tempRawBytes[6]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[5];
 897              	 .loc 2 211 0
 898 0268 0E4B     	 ldr r3,.L66+12
 899 026a 1B68     	 ldr r3,[r3]
 900 026c 5A7D     	 ldrb r2,[r3,#21]
 901 026e 0F4B     	 ldr r3,.L66+20
 902 0270 9A77     	 strb r2,[r3,#30]
 212:../main.c     **** 						smartdata.tempRawBytes[7]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[4];
 903              	 .loc 2 212 0
 904 0272 0C4B     	 ldr r3,.L66+12
 905 0274 1B68     	 ldr r3,[r3]
 906 0276 1A7D     	 ldrb r2,[r3,#20]
 907 0278 0C4B     	 ldr r3,.L66+20
 908 027a DA77     	 strb r2,[r3,#31]
 213:../main.c     **** 						smartdata.tempRawBytes[8]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[7];
 909              	 .loc 2 213 0
 910 027c 094B     	 ldr r3,.L66+12
 911 027e 1B68     	 ldr r3,[r3]
 912 0280 DA7D     	 ldrb r2,[r3,#23]
 913 0282 0A4B     	 ldr r3,.L66+20
 914 0284 83F82020 	 strb r2,[r3,#32]
 214:../main.c     **** 						smartdata.tempRawBytes[9]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[6];
 915              	 .loc 2 214 0
 916 0288 064B     	 ldr r3,.L66+12
 917 028a 1B68     	 ldr r3,[r3]
 918 028c 9A7D     	 ldrb r2,[r3,#22]
 919 028e 074B     	 ldr r3,.L66+20
 920 0290 83F82120 	 strb r2,[r3,#33]
 921 0294 B5E0     	 b .L42
 922              	.L67:
 923 0296 00BF     	 .align 2
 924              	.L66:
 925 0298 00000000 	 .word CAN_OBDII
 926 029c 00000000 	 .word canTimeoutCounter
 927 02a0 00000000 	 .word state
 928 02a4 00000000 	 .word CAN_OBDII_LMO_02_Config
 929 02a8 398EE338 	 .word 954437177
 930 02ac 00000000 	 .word smartdata
 931 02b0 00000000 	 .word CAN_OBDII_LMO_01_Config
 932 02b4 00000000 	 .word reqBattAmp
 933 02b8 00000000 	 .word onProcess
 934 02bc 00000042 	 .word 1107296256
 935 02c0 00000000 	 .word reqBattVolt
 936 02c4 00000000 	 .word stateBattVolt
 937 02c8 00000000 	 .word flowControl
 938 02cc 00008042 	 .word 1115684864
 939 02d0 00000000 	 .word reqModuleTemps
 940 02d4 00000000 	 .word stateModuleTemps
 941              	.L41:
 215:../main.c     **** 					}
 216:../main.c     **** 					else if(CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[0] == 0x22)
 942              	 .loc 2 216 0
 943 02d8 A54B     	 ldr r3,.L68
 944 02da 1B68     	 ldr r3,[r3]
 945 02dc 1B7C     	 ldrb r3,[r3,#16]
 946 02de 222B     	 cmp r3,#34
 947 02e0 2AD1     	 bne .L43
 217:../main.c     **** 					{
 218:../main.c     **** 						smartdata.tempRawBytes[10]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[2];
 948              	 .loc 2 218 0
 949 02e2 A34B     	 ldr r3,.L68
 950 02e4 1B68     	 ldr r3,[r3]
 951 02e6 9A7C     	 ldrb r2,[r3,#18]
 952 02e8 A24B     	 ldr r3,.L68+4
 953 02ea 83F82220 	 strb r2,[r3,#34]
 219:../main.c     **** 						smartdata.tempRawBytes[11]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[1];
 954              	 .loc 2 219 0
 955 02ee A04B     	 ldr r3,.L68
 956 02f0 1B68     	 ldr r3,[r3]
 957 02f2 5A7C     	 ldrb r2,[r3,#17]
 958 02f4 9F4B     	 ldr r3,.L68+4
 959 02f6 83F82320 	 strb r2,[r3,#35]
 220:../main.c     **** 						smartdata.tempRawBytes[12]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[4];
 960              	 .loc 2 220 0
 961 02fa 9D4B     	 ldr r3,.L68
 962 02fc 1B68     	 ldr r3,[r3]
 963 02fe 1A7D     	 ldrb r2,[r3,#20]
 964 0300 9C4B     	 ldr r3,.L68+4
 965 0302 83F82420 	 strb r2,[r3,#36]
 221:../main.c     **** 						smartdata.tempRawBytes[13]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[3];
 966              	 .loc 2 221 0
 967 0306 9A4B     	 ldr r3,.L68
 968 0308 1B68     	 ldr r3,[r3]
 969 030a DA7C     	 ldrb r2,[r3,#19]
 970 030c 994B     	 ldr r3,.L68+4
 971 030e 83F82520 	 strb r2,[r3,#37]
 222:../main.c     **** 						smartdata.tempRawBytes[14]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[6];
 972              	 .loc 2 222 0
 973 0312 974B     	 ldr r3,.L68
 974 0314 1B68     	 ldr r3,[r3]
 975 0316 9A7D     	 ldrb r2,[r3,#22]
 976 0318 964B     	 ldr r3,.L68+4
 977 031a 83F82620 	 strb r2,[r3,#38]
 223:../main.c     **** 						smartdata.tempRawBytes[15]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[5];
 978              	 .loc 2 223 0
 979 031e 944B     	 ldr r3,.L68
 980 0320 1B68     	 ldr r3,[r3]
 981 0322 5A7D     	 ldrb r2,[r3,#21]
 982 0324 934B     	 ldr r3,.L68+4
 983 0326 83F82720 	 strb r2,[r3,#39]
 224:../main.c     **** 						smartdata.tempRawBytes[17]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[7];
 984              	 .loc 2 224 0
 985 032a 914B     	 ldr r3,.L68
 986 032c 1B68     	 ldr r3,[r3]
 987 032e DA7D     	 ldrb r2,[r3,#23]
 988 0330 904B     	 ldr r3,.L68+4
 989 0332 83F82920 	 strb r2,[r3,#41]
 990 0336 64E0     	 b .L42
 991              	.L43:
 225:../main.c     **** 					}
 226:../main.c     **** 					else if(CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[0] == 0x23)
 992              	 .loc 2 226 0
 993 0338 8D4B     	 ldr r3,.L68
 994 033a 1B68     	 ldr r3,[r3]
 995 033c 1B7C     	 ldrb r3,[r3,#16]
 996 033e 232B     	 cmp r3,#35
 997 0340 06D1     	 bne .L44
 227:../main.c     **** 					{
 228:../main.c     **** 						smartdata.tempRawBytes[16]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[1];
 998              	 .loc 2 228 0
 999 0342 8B4B     	 ldr r3,.L68
 1000 0344 1B68     	 ldr r3,[r3]
 1001 0346 5A7C     	 ldrb r2,[r3,#17]
 1002 0348 8A4B     	 ldr r3,.L68+4
 1003 034a 83F82820 	 strb r2,[r3,#40]
 1004 034e 58E0     	 b .L42
 1005              	.L44:
 229:../main.c     **** 					}
 230:../main.c     **** 					else if(CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[0] > 0x23 && CAN_OBDII_LMO_02_Config.mo_
 1006              	 .loc 2 230 0
 1007 0350 874B     	 ldr r3,.L68
 1008 0352 1B68     	 ldr r3,[r3]
 1009 0354 1B7C     	 ldrb r3,[r3,#16]
 1010 0356 232B     	 cmp r3,#35
 1011 0358 05D9     	 bls .L45
 1012              	 .loc 2 230 0 is_stmt 0 discriminator 1
 1013 035a 854B     	 ldr r3,.L68
 1014 035c 1B68     	 ldr r3,[r3]
 1015 035e 1B7C     	 ldrb r3,[r3,#16]
 1016 0360 272B     	 cmp r3,#39
 1017 0362 00D8     	 bhi .L45
 1018              	 .loc 2 230 0
 1019 0364 4DE0     	 b .L42
 1020              	.L45:
 231:../main.c     **** 					{
 232:../main.c     **** 						// ignore these packages.
 233:../main.c     **** 					}
 234:../main.c     **** 					else if(CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[0] == 0x28)
 1021              	 .loc 2 234 0 is_stmt 1
 1022 0366 824B     	 ldr r3,.L68
 1023 0368 1B68     	 ldr r3,[r3]
 1024 036a 1B7C     	 ldrb r3,[r3,#16]
 1025 036c 282B     	 cmp r3,#40
 1026 036e 07D1     	 bne .L46
 235:../main.c     **** 					{
 236:../main.c     **** 						CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,flowControl);
 1027              	 .loc 2 236 0
 1028 0370 8148     	 ldr r0,.L68+8
 1029 0372 8249     	 ldr r1,.L68+12
 1030 0374 FFF7FEFF 	 bl CAN_NODE_MO_UpdateData
 237:../main.c     **** 						CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
 1031              	 .loc 2 237 0
 1032 0378 7F48     	 ldr r0,.L68+8
 1033 037a FFF7FEFF 	 bl CAN_NODE_MO_Transmit
 1034 037e 40E0     	 b .L42
 1035              	.L46:
 238:../main.c     **** 					}
 239:../main.c     **** 					else if(CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[0] == 0x29)
 1036              	 .loc 2 239 0
 1037 0380 7B4B     	 ldr r3,.L68
 1038 0382 1B68     	 ldr r3,[r3]
 1039 0384 1B7C     	 ldrb r3,[r3,#16]
 1040 0386 292B     	 cmp r3,#41
 1041 0388 3BD1     	 bne .L42
 1042              	.LBB2:
 240:../main.c     **** 					{
 241:../main.c     **** 						uint8_t erhan = 0;
 1043              	 .loc 2 241 0
 1044 038a 0023     	 movs r3,#0
 1045 038c FB71     	 strb r3,[r7,#7]
 242:../main.c     **** 						for(erhan = 0; erhan < 9; erhan++)
 1046              	 .loc 2 242 0
 1047 038e 0023     	 movs r3,#0
 1048 0390 FB71     	 strb r3,[r7,#7]
 1049 0392 1EE0     	 b .L47
 1050              	.L48:
 243:../main.c     **** 						{
 244:../main.c     **** 							smartdata.temps[erhan]=(float)(smartdata.tempRawBytes[2*erhan+1]*256 +smartdata.tempRawBytes
 1051              	 .loc 2 244 0 discriminator 3
 1052 0394 FB79     	 ldrb r3,[r7,#7]
 1053 0396 FA79     	 ldrb r2,[r7,#7]
 1054 0398 5200     	 lsls r2,r2,#1
 1055 039a 0132     	 adds r2,r2,#1
 1056 039c 7549     	 ldr r1,.L68+4
 1057 039e 0A44     	 add r2,r2,r1
 1058 03a0 127E     	 ldrb r2,[r2,#24]
 1059 03a2 1202     	 lsls r2,r2,#8
 1060 03a4 F979     	 ldrb r1,[r7,#7]
 1061 03a6 4900     	 lsls r1,r1,#1
 1062 03a8 7248     	 ldr r0,.L68+4
 1063 03aa 0144     	 add r1,r1,r0
 1064 03ac 097E     	 ldrb r1,[r1,#24]
 1065 03ae 0A44     	 add r2,r2,r1
 1066 03b0 07EE902A 	 fmsr s15,r2
 1067 03b4 F8EEE77A 	 fsitos s15,s15
 1068 03b8 9FED717A 	 flds s14,.L68+16
 1069 03bc C7EE877A 	 fdivs s15,s15,s14
 1070 03c0 6C4A     	 ldr r2,.L68+4
 1071 03c2 0A33     	 adds r3,r3,#10
 1072 03c4 9B00     	 lsls r3,r3,#2
 1073 03c6 1344     	 add r3,r3,r2
 1074 03c8 C3ED017A 	 fsts s15,[r3,#4]
 242:../main.c     **** 						for(erhan = 0; erhan < 9; erhan++)
 1075              	 .loc 2 242 0 discriminator 3
 1076 03cc FB79     	 ldrb r3,[r7,#7]
 1077 03ce 0133     	 adds r3,r3,#1
 1078 03d0 FB71     	 strb r3,[r7,#7]
 1079              	.L47:
 242:../main.c     **** 						for(erhan = 0; erhan < 9; erhan++)
 1080              	 .loc 2 242 0 is_stmt 0 discriminator 1
 1081 03d2 FB79     	 ldrb r3,[r7,#7]
 1082 03d4 082B     	 cmp r3,#8
 1083 03d6 DDD9     	 bls .L48
 245:../main.c     **** 						}
 246:../main.c     **** 
 247:../main.c     **** 
 248:../main.c     **** 						sampleCounter++;
 1084              	 .loc 2 248 0 is_stmt 1
 1085 03d8 6A4B     	 ldr r3,.L68+20
 1086 03da 1B68     	 ldr r3,[r3]
 1087 03dc 0133     	 adds r3,r3,#1
 1088 03de 694A     	 ldr r2,.L68+20
 1089 03e0 1360     	 str r3,[r2]
 249:../main.c     **** 						/*
 250:../main.c     **** 						if(!(sampleCounter%CELL_VOLTAGES_SAMPLING_PERIOD))
 251:../main.c     **** 						{
 252:../main.c     **** 							CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,reqCellVoltages);
 253:../main.c     **** 							CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
 254:../main.c     **** 							state = GET_CELL_VOLTAGES;
 255:../main.c     **** 							stateCellVoltages = CELL_VOLTAGES_REQ_RESPONSE;
 256:../main.c     **** 						}
 257:../main.c     **** 						else
 258:../main.c     **** 						{
 259:../main.c     **** 						*/
 260:../main.c     **** 							XMC_GPIO_ToggleOutput(LED2);
 1090              	 .loc 2 260 0
 1091 03e2 6948     	 ldr r0,.L68+24
 1092 03e4 0021     	 movs r1,#0
 1093 03e6 FFF7FEFF 	 bl XMC_GPIO_ToggleOutput
 261:../main.c     **** 							dataUpdated = 1;
 1094              	 .loc 2 261 0
 1095 03ea 684B     	 ldr r3,.L68+28
 1096 03ec 0122     	 movs r2,#1
 1097 03ee 1A70     	 strb r2,[r3]
 262:../main.c     **** 							onProcess = 0;
 1098              	 .loc 2 262 0
 1099 03f0 674B     	 ldr r3,.L68+32
 1100 03f2 0022     	 movs r2,#0
 1101 03f4 1A70     	 strb r2,[r3]
 263:../main.c     **** 							canTimeoutTimerEnable=0;
 1102              	 .loc 2 263 0
 1103 03f6 674B     	 ldr r3,.L68+36
 1104 03f8 0022     	 movs r2,#0
 1105 03fa 1A70     	 strb r2,[r3]
 264:../main.c     **** 							state = IDLE;
 1106              	 .loc 2 264 0
 1107 03fc 664B     	 ldr r3,.L68+40
 1108 03fe 0022     	 movs r2,#0
 1109 0400 1A70     	 strb r2,[r3]
 1110              	.L42:
 1111              	.LBE2:
 265:../main.c     **** 						//}
 266:../main.c     **** 					}
 267:../main.c     **** 					else
 268:../main.c     **** 					{
 269:../main.c     **** 						///< Think about what to do here!!!
 270:../main.c     **** 						/*
 271:../main.c     **** 						CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,reqModuleTemps);
 272:../main.c     **** 						CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
 273:../main.c     **** 						stateModuleTemps = MODULE_TEMPS_REQ_RESPONSE;
 274:../main.c     **** 						*/
 275:../main.c     **** 					}
 276:../main.c     **** 				break;
 1112              	 .loc 2 276 0 discriminator 4
 1113 0402 06E0     	 b .L40
 1114              	.L63:
 277:../main.c     **** 
 278:../main.c     **** 				default:
 279:../main.c     **** 				case MODULE_TEMPS_IDLE:
 280:../main.c     **** 					onProcess=0;
 1115              	 .loc 2 280 0
 1116 0404 624B     	 ldr r3,.L68+32
 1117 0406 0022     	 movs r2,#0
 1118 0408 1A70     	 strb r2,[r3]
 281:../main.c     **** 					state=IDLE;
 1119              	 .loc 2 281 0
 1120 040a 634B     	 ldr r3,.L68+40
 1121 040c 0022     	 movs r2,#0
 1122 040e 1A70     	 strb r2,[r3]
 282:../main.c     **** 				break;
 1123              	 .loc 2 282 0
 1124 0410 00BF     	 nop
 1125              	.L40:
 283:../main.c     **** 			}
 284:../main.c     **** 		break;
 1126              	 .loc 2 284 0 discriminator 5
 1127 0412 AAE0     	 b .L14
 1128              	.L22:
 285:../main.c     **** 
 286:../main.c     **** 		case GET_CELL_VOLTAGES:
 287:../main.c     **** 			switch(stateCellVoltages)
 1129              	 .loc 2 287 0
 1130 0414 614B     	 ldr r3,.L68+44
 1131 0416 1B78     	 ldrb r3,[r3]
 1132 0418 022B     	 cmp r3,#2
 1133 041a 32D0     	 beq .L50
 1134 041c 032B     	 cmp r3,#3
 1135 041e 00F0A280 	 beq .L65
 1136 0422 012B     	 cmp r3,#1
 1137 0424 40F09880 	 bne .L64
 1138              	.LBB3:
 288:../main.c     **** 			{
 289:../main.c     **** 				uint8_t erhan;
 290:../main.c     **** 				case CELL_VOLTAGES_REQ_RESPONSE:
 291:../main.c     **** 					if(CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[2] == 0x62)
 1139              	 .loc 2 291 0
 1140 0428 514B     	 ldr r3,.L68
 1141 042a 1B68     	 ldr r3,[r3]
 1142 042c 9B7C     	 ldrb r3,[r3,#18]
 1143 042e 622B     	 cmp r3,#98
 1144 0430 1FD1     	 bne .L53
 292:../main.c     **** 					{
 293:../main.c     **** 						smartdata.cellVotlagesBytes[0] = CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[5];
 1145              	 .loc 2 293 0
 1146 0432 4F4B     	 ldr r3,.L68
 1147 0434 1B68     	 ldr r3,[r3]
 1148 0436 5A7D     	 ldrb r2,[r3,#21]
 1149 0438 4E4B     	 ldr r3,.L68+4
 1150 043a 83F85020 	 strb r2,[r3,#80]
 294:../main.c     **** 						smartdata.cellVotlagesBytes[1] = CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[6];
 1151              	 .loc 2 294 0
 1152 043e 4C4B     	 ldr r3,.L68
 1153 0440 1B68     	 ldr r3,[r3]
 1154 0442 9A7D     	 ldrb r2,[r3,#22]
 1155 0444 4B4B     	 ldr r3,.L68+4
 1156 0446 83F85120 	 strb r2,[r3,#81]
 295:../main.c     **** 						smartdata.cellVotlagesBytes[2] = CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[7];
 1157              	 .loc 2 295 0
 1158 044a 494B     	 ldr r3,.L68
 1159 044c 1B68     	 ldr r3,[r3]
 1160 044e DA7D     	 ldrb r2,[r3,#23]
 1161 0450 484B     	 ldr r3,.L68+4
 1162 0452 83F85220 	 strb r2,[r3,#82]
 296:../main.c     **** 						CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,flowControl);
 1163              	 .loc 2 296 0
 1164 0456 4848     	 ldr r0,.L68+8
 1165 0458 4849     	 ldr r1,.L68+12
 1166 045a FFF7FEFF 	 bl CAN_NODE_MO_UpdateData
 297:../main.c     **** 						CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
 1167              	 .loc 2 297 0
 1168 045e 4648     	 ldr r0,.L68+8
 1169 0460 FFF7FEFF 	 bl CAN_NODE_MO_Transmit
 298:../main.c     **** 						stateCellVoltages = CELL_VOLTAGES_FLOW_CONTROL;
 1170              	 .loc 2 298 0
 1171 0464 4D4B     	 ldr r3,.L68+44
 1172 0466 0222     	 movs r2,#2
 1173 0468 1A70     	 strb r2,[r3]
 299:../main.c     **** 						cellVoltagesFlowCounter = 1;								// Set flow control count to 1.
 1174              	 .loc 2 299 0
 1175 046a 4D4B     	 ldr r3,.L68+48
 1176 046c 0122     	 movs r2,#1
 1177 046e 1A70     	 strb r2,[r3]
 300:../main.c     **** 					}
 301:../main.c     **** 					else
 302:../main.c     **** 					{
 303:../main.c     **** 						CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,reqCellVoltages);
 304:../main.c     **** 						CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
 305:../main.c     **** 					}
 306:../main.c     **** 
 307:../main.c     **** 				break;
 1178              	 .loc 2 307 0
 1179 0470 7AE0     	 b .L55
 1180              	.L53:
 303:../main.c     **** 						CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
 1181              	 .loc 2 303 0
 1182 0472 4148     	 ldr r0,.L68+8
 1183 0474 4B49     	 ldr r1,.L68+52
 1184 0476 FFF7FEFF 	 bl CAN_NODE_MO_UpdateData
 304:../main.c     **** 					}
 1185              	 .loc 2 304 0
 1186 047a 3F48     	 ldr r0,.L68+8
 1187 047c FFF7FEFF 	 bl CAN_NODE_MO_Transmit
 1188              	 .loc 2 307 0
 1189 0480 72E0     	 b .L55
 1190              	.L50:
 308:../main.c     **** 
 309:../main.c     **** 				case CELL_VOLTAGES_FLOW_CONTROL:
 310:../main.c     **** 					// Read flow control responses and save data bytes according to package indexes.
 311:../main.c     **** 
 312:../main.c     **** 					erhan = (CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[0]-1) & 0x7;
 1191              	 .loc 2 312 0
 1192 0482 3B4B     	 ldr r3,.L68
 1193 0484 1B68     	 ldr r3,[r3]
 1194 0486 1B7C     	 ldrb r3,[r3,#16]
 1195 0488 013B     	 subs r3,r3,#1
 1196 048a DBB2     	 uxtb r3,r3
 1197 048c 03F00703 	 and r3,r3,#7
 1198 0490 7B71     	 strb r3,[r7,#5]
 313:../main.c     **** 
 314:../main.c     **** 					if(cellVoltagesFlowCounter <= CELL_VOLTAGES_DATA_FLOW_COUNT)
 1199              	 .loc 2 314 0
 1200 0492 434B     	 ldr r3,.L68+48
 1201 0494 1B78     	 ldrb r3,[r3]
 1202 0496 042B     	 cmp r3,#4
 1203 0498 23D8     	 bhi .L56
 1204              	.LBB4:
 315:../main.c     **** 					{
 316:../main.c     **** 						for(uint8_t erhan2=0; erhan2<7;erhan2++)
 1205              	 .loc 2 316 0
 1206 049a 0023     	 movs r3,#0
 1207 049c BB71     	 strb r3,[r7,#6]
 1208 049e 1DE0     	 b .L57
 1209              	.L58:
 317:../main.c     **** 						{
 318:../main.c     **** 							smartdata.cellVotlagesBytes[(cellVoltagesFlowCounter-1)*56 + 7*erhan + 3 + erhan2] = CAN_OBD
 1210              	 .loc 2 318 0 discriminator 3
 1211 04a0 3F4B     	 ldr r3,.L68+48
 1212 04a2 1B78     	 ldrb r3,[r3]
 1213 04a4 5A1E     	 subs r2,r3,#1
 1214 04a6 1346     	 mov r3,r2
 1215 04a8 DB00     	 lsls r3,r3,#3
 1216 04aa 9B1A     	 subs r3,r3,r2
 1217 04ac DB00     	 lsls r3,r3,#3
 1218 04ae 1946     	 mov r1,r3
 1219 04b0 7A79     	 ldrb r2,[r7,#5]
 1220 04b2 1346     	 mov r3,r2
 1221 04b4 DB00     	 lsls r3,r3,#3
 1222 04b6 9B1A     	 subs r3,r3,r2
 1223 04b8 0B44     	 add r3,r3,r1
 1224 04ba DA1C     	 adds r2,r3,#3
 1225 04bc BB79     	 ldrb r3,[r7,#6]
 1226 04be 1344     	 add r3,r3,r2
 1227 04c0 2B4A     	 ldr r2,.L68
 1228 04c2 1168     	 ldr r1,[r2]
 1229 04c4 BA79     	 ldrb r2,[r7,#6]
 1230 04c6 0132     	 adds r2,r2,#1
 1231 04c8 0A44     	 add r2,r2,r1
 1232 04ca 117C     	 ldrb r1,[r2,#16]
 1233 04cc 294A     	 ldr r2,.L68+4
 1234 04ce 1344     	 add r3,r3,r2
 1235 04d0 0A46     	 mov r2,r1
 1236 04d2 83F85020 	 strb r2,[r3,#80]
 316:../main.c     **** 						{
 1237              	 .loc 2 316 0 discriminator 3
 1238 04d6 BB79     	 ldrb r3,[r7,#6]
 1239 04d8 0133     	 adds r3,r3,#1
 1240 04da BB71     	 strb r3,[r7,#6]
 1241              	.L57:
 316:../main.c     **** 						{
 1242              	 .loc 2 316 0 is_stmt 0 discriminator 1
 1243 04dc BB79     	 ldrb r3,[r7,#6]
 1244 04de 062B     	 cmp r3,#6
 1245 04e0 DED9     	 bls .L58
 1246              	.L56:
 1247              	.LBE4:
 319:../main.c     **** 						}
 320:../main.c     **** 					}
 321:../main.c     **** 					//////////////////////////////////////////////////////////////////////////////
 322:../main.c     **** 
 323:../main.c     **** 					if(cellVoltagesFlowCounter >= CELL_VOLTAGES_FLOW_COUNT)
 1248              	 .loc 2 323 0 is_stmt 1
 1249 04e2 2F4B     	 ldr r3,.L68+48
 1250 04e4 1B78     	 ldrb r3,[r3]
 1251 04e6 072B     	 cmp r3,#7
 1252 04e8 17D9     	 bls .L59
 324:../main.c     **** 					{
 325:../main.c     **** 						if(CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[0] == 0x29)
 1253              	 .loc 2 325 0
 1254 04ea 214B     	 ldr r3,.L68
 1255 04ec 1B68     	 ldr r3,[r3]
 1256 04ee 1B7C     	 ldrb r3,[r3,#16]
 1257 04f0 292B     	 cmp r3,#41
 1258 04f2 12D1     	 bne .L59
 326:../main.c     **** 						{
 327:../main.c     **** 							XMC_GPIO_ToggleOutput(LED2);
 1259              	 .loc 2 327 0
 1260 04f4 2448     	 ldr r0,.L68+24
 1261 04f6 0021     	 movs r1,#0
 1262 04f8 FFF7FEFF 	 bl XMC_GPIO_ToggleOutput
 328:../main.c     **** 							dataUpdated = 1;
 1263              	 .loc 2 328 0
 1264 04fc 234B     	 ldr r3,.L68+28
 1265 04fe 0122     	 movs r2,#1
 1266 0500 1A70     	 strb r2,[r3]
 329:../main.c     **** 							onProcess = 0;
 1267              	 .loc 2 329 0
 1268 0502 234B     	 ldr r3,.L68+32
 1269 0504 0022     	 movs r2,#0
 1270 0506 1A70     	 strb r2,[r3]
 330:../main.c     **** 							canTimeoutTimerEnable=0;
 1271              	 .loc 2 330 0
 1272 0508 224B     	 ldr r3,.L68+36
 1273 050a 0022     	 movs r2,#0
 1274 050c 1A70     	 strb r2,[r3]
 331:../main.c     **** 							cellVoltagesUpdated = 1;
 1275              	 .loc 2 331 0
 1276 050e 264B     	 ldr r3,.L68+56
 1277 0510 0122     	 movs r2,#1
 1278 0512 1A70     	 strb r2,[r3]
 332:../main.c     **** 							state = IDLE;
 1279              	 .loc 2 332 0
 1280 0514 204B     	 ldr r3,.L68+40
 1281 0516 0022     	 movs r2,#0
 1282 0518 1A70     	 strb r2,[r3]
 1283              	.L59:
 333:../main.c     **** 						}
 334:../main.c     **** 					}
 335:../main.c     **** 					// Check if it is the time to sent next flow control package.
 336:../main.c     **** 					if((CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[0] % 0x8) == 0)
 1284              	 .loc 2 336 0
 1285 051a 154B     	 ldr r3,.L68
 1286 051c 1B68     	 ldr r3,[r3]
 1287 051e 1B7C     	 ldrb r3,[r3,#16]
 1288 0520 03F00703 	 and r3,r3,#7
 1289 0524 DBB2     	 uxtb r3,r3
 1290 0526 002B     	 cmp r3,#0
 1291 0528 15D1     	 bne .L60
 337:../main.c     **** 					{
 338:../main.c     **** 						cellVoltagesFlowCounter++;	// Increase the flow counter variable.
 1292              	 .loc 2 338 0
 1293 052a 1D4B     	 ldr r3,.L68+48
 1294 052c 1B78     	 ldrb r3,[r3]
 1295 052e 0133     	 adds r3,r3,#1
 1296 0530 DAB2     	 uxtb r2,r3
 1297 0532 1B4B     	 ldr r3,.L68+48
 1298 0534 1A70     	 strb r2,[r3]
 339:../main.c     **** 						if(cellVoltagesFlowCounter <= CELL_VOLTAGES_FLOW_COUNT)	// Check if all flow control packages
 1299              	 .loc 2 339 0
 1300 0536 1A4B     	 ldr r3,.L68+48
 1301 0538 1B78     	 ldrb r3,[r3]
 1302 053a 082B     	 cmp r3,#8
 1303 053c 07D8     	 bhi .L61
 340:../main.c     **** 						{
 341:../main.c     **** 							// Send next flow control package.
 342:../main.c     **** 							CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,flowControl);
 1304              	 .loc 2 342 0
 1305 053e 0E48     	 ldr r0,.L68+8
 1306 0540 0E49     	 ldr r1,.L68+12
 1307 0542 FFF7FEFF 	 bl CAN_NODE_MO_UpdateData
 343:../main.c     **** 							CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
 1308              	 .loc 2 343 0
 1309 0546 0C48     	 ldr r0,.L68+8
 1310 0548 FFF7FEFF 	 bl CAN_NODE_MO_Transmit
 1311 054c 03E0     	 b .L60
 1312              	.L61:
 344:../main.c     **** 						}
 345:../main.c     **** 						else	// If all flow control packages sent.
 346:../main.c     **** 						{
 347:../main.c     **** 							///< Think about what to do here!!!
 348:../main.c     **** 							state = IDLE;
 1313              	 .loc 2 348 0
 1314 054e 124B     	 ldr r3,.L68+40
 1315 0550 0022     	 movs r2,#0
 1316 0552 1A70     	 strb r2,[r3]
 349:../main.c     **** 						}
 350:../main.c     **** 					}
 351:../main.c     **** 				break;
 1317              	 .loc 2 351 0
 1318 0554 08E0     	 b .L55
 1319              	.L60:
 1320              	 .loc 2 351 0 is_stmt 0 discriminator 7
 1321 0556 07E0     	 b .L55
 1322              	.L64:
 352:../main.c     **** 
 353:../main.c     **** 				case CELL_VOLTAGES_LAST_FLOW_PACKAGE:
 354:../main.c     **** 
 355:../main.c     **** 				break;
 356:../main.c     **** 
 357:../main.c     **** 				default:
 358:../main.c     **** 				case CELL_VOLTAGES_IDLE:
 359:../main.c     **** 					onProcess=0;
 1323              	 .loc 2 359 0 is_stmt 1
 1324 0558 0D4B     	 ldr r3,.L68+32
 1325 055a 0022     	 movs r2,#0
 1326 055c 1A70     	 strb r2,[r3]
 360:../main.c     **** 					state=IDLE;
 1327              	 .loc 2 360 0
 1328 055e 0E4B     	 ldr r3,.L68+40
 1329 0560 0022     	 movs r2,#0
 1330 0562 1A70     	 strb r2,[r3]
 361:../main.c     **** 				break;
 1331              	 .loc 2 361 0
 1332 0564 00E0     	 b .L55
 1333              	.L65:
 355:../main.c     **** 
 1334              	 .loc 2 355 0
 1335 0566 00BF     	 nop
 1336              	.L55:
 1337              	.LBE3:
 362:../main.c     **** 			}
 363:../main.c     **** 		break;
 1338              	 .loc 2 363 0 discriminator 6
 1339 0568 00BF     	 nop
 1340              	.L14:
 364:../main.c     **** 	}
 365:../main.c     **** }
 1341              	 .loc 2 365 0
 1342 056a 0837     	 adds r7,r7,#8
 1343              	.LCFI25:
 1344              	 .cfi_def_cfa_offset 8
 1345 056c BD46     	 mov sp,r7
 1346              	.LCFI26:
 1347              	 .cfi_def_cfa_register 13
 1348              	 
 1349 056e 80BD     	 pop {r7,pc}
 1350              	.L69:
 1351              	 .align 2
 1352              	.L68:
 1353 0570 00000000 	 .word CAN_OBDII_LMO_02_Config
 1354 0574 00000000 	 .word smartdata
 1355 0578 00000000 	 .word CAN_OBDII_LMO_01_Config
 1356 057c 00000000 	 .word flowControl
 1357 0580 00008042 	 .word 1115684864
 1358 0584 00000000 	 .word sampleCounter
 1359 0588 00810248 	 .word 1208123648
 1360 058c 00000000 	 .word dataUpdated
 1361 0590 00000000 	 .word onProcess
 1362 0594 00000000 	 .word canTimeoutTimerEnable
 1363 0598 00000000 	 .word state
 1364 059c 00000000 	 .word stateCellVoltages
 1365 05a0 00000000 	 .word cellVoltagesFlowCounter
 1366 05a4 00000000 	 .word reqCellVoltages
 1367 05a8 00000000 	 .word cellVoltagesUpdated
 1368              	 .cfi_endproc
 1369              	.LFE435:
 1371              	 .section .rodata
 1372              	 .align 2
 1373              	.LC1:
 1374 0000 00       	 .ascii "\000"
 1375              	 .section .text.writeToEndOfFile,"ax",%progbits
 1376              	 .align 2
 1377              	 .global writeToEndOfFile
 1378              	 .thumb
 1379              	 .thumb_func
 1381              	writeToEndOfFile:
 1382              	.LFB436:
 366:../main.c     **** 
 367:../main.c     **** BYTE writeToEndOfFile(FATFS* fs, FIL* fp, const TCHAR* path, const void *buff, UINT btw)
 368:../main.c     **** {
 1383              	 .loc 2 368 0
 1384              	 .cfi_startproc
 1385              	 
 1386              	 
 1387 0000 80B5     	 push {r7,lr}
 1388              	.LCFI27:
 1389              	 .cfi_def_cfa_offset 8
 1390              	 .cfi_offset 7,-8
 1391              	 .cfi_offset 14,-4
 1392 0002 86B0     	 sub sp,sp,#24
 1393              	.LCFI28:
 1394              	 .cfi_def_cfa_offset 32
 1395 0004 00AF     	 add r7,sp,#0
 1396              	.LCFI29:
 1397              	 .cfi_def_cfa_register 7
 1398 0006 F860     	 str r0,[r7,#12]
 1399 0008 B960     	 str r1,[r7,#8]
 1400 000a 7A60     	 str r2,[r7,#4]
 1401 000c 3B60     	 str r3,[r7]
 369:../main.c     **** 	UINT bw;
 370:../main.c     **** 	if(f_mount(fs,"",0) == FR_OK)
 1402              	 .loc 2 370 0
 1403 000e F868     	 ldr r0,[r7,#12]
 1404 0010 1849     	 ldr r1,.L74
 1405 0012 0022     	 movs r2,#0
 1406 0014 FFF7FEFF 	 bl f_mount
 1407 0018 0346     	 mov r3,r0
 1408 001a 002B     	 cmp r3,#0
 1409 001c 22D1     	 bne .L71
 371:../main.c     **** 	{
 372:../main.c     **** 		if (f_open(fp, path, FA_OPEN_ALWAYS | FA_WRITE) == FR_OK)
 1410              	 .loc 2 372 0
 1411 001e B868     	 ldr r0,[r7,#8]
 1412 0020 7968     	 ldr r1,[r7,#4]
 1413 0022 1222     	 movs r2,#18
 1414 0024 FFF7FEFF 	 bl f_open
 1415 0028 0346     	 mov r3,r0
 1416 002a 002B     	 cmp r3,#0
 1417 002c 1AD1     	 bne .L71
 373:../main.c     **** 		{
 374:../main.c     **** 			if(f_lseek(fp, f_size(fp)) == FR_OK)
 1418              	 .loc 2 374 0
 1419 002e BB68     	 ldr r3,[r7,#8]
 1420 0030 DB68     	 ldr r3,[r3,#12]
 1421 0032 B868     	 ldr r0,[r7,#8]
 1422 0034 1946     	 mov r1,r3
 1423 0036 FFF7FEFF 	 bl f_lseek
 1424 003a 0346     	 mov r3,r0
 1425 003c 002B     	 cmp r3,#0
 1426 003e 11D1     	 bne .L71
 375:../main.c     **** 			{
 376:../main.c     **** 				if(f_write(fp, buff, btw, &bw) == FR_OK)
 1427              	 .loc 2 376 0
 1428 0040 07F11403 	 add r3,r7,#20
 1429 0044 B868     	 ldr r0,[r7,#8]
 1430 0046 3968     	 ldr r1,[r7]
 1431 0048 3A6A     	 ldr r2,[r7,#32]
 1432 004a FFF7FEFF 	 bl f_write
 1433 004e 0346     	 mov r3,r0
 1434 0050 002B     	 cmp r3,#0
 1435 0052 07D1     	 bne .L71
 377:../main.c     **** 				{
 378:../main.c     **** 					if(f_close(fp) == FR_OK)
 1436              	 .loc 2 378 0
 1437 0054 B868     	 ldr r0,[r7,#8]
 1438 0056 FFF7FEFF 	 bl f_close
 1439 005a 0346     	 mov r3,r0
 1440 005c 002B     	 cmp r3,#0
 1441 005e 01D1     	 bne .L71
 379:../main.c     **** 					{
 380:../main.c     **** 						return 0;
 1442              	 .loc 2 380 0
 1443 0060 0023     	 movs r3,#0
 1444 0062 03E0     	 b .L73
 1445              	.L71:
 381:../main.c     **** 					}
 382:../main.c     **** 				}
 383:../main.c     **** 			}
 384:../main.c     **** 		}
 385:../main.c     **** 	}
 386:../main.c     **** 	f_close(fp);
 1446              	 .loc 2 386 0
 1447 0064 B868     	 ldr r0,[r7,#8]
 1448 0066 FFF7FEFF 	 bl f_close
 387:../main.c     **** 	return 1;
 1449              	 .loc 2 387 0
 1450 006a 0123     	 movs r3,#1
 1451              	.L73:
 388:../main.c     **** }
 1452              	 .loc 2 388 0 discriminator 1
 1453 006c 1846     	 mov r0,r3
 1454 006e 1837     	 adds r7,r7,#24
 1455              	.LCFI30:
 1456              	 .cfi_def_cfa_offset 8
 1457 0070 BD46     	 mov sp,r7
 1458              	.LCFI31:
 1459              	 .cfi_def_cfa_register 13
 1460              	 
 1461 0072 80BD     	 pop {r7,pc}
 1462              	.L75:
 1463              	 .align 2
 1464              	.L74:
 1465 0074 00000000 	 .word .LC1
 1466              	 .cfi_endproc
 1467              	.LFE436:
 1469              	 .section .rodata
 1470 0001 000000   	 .align 2
 1471              	.LC2:
 1472 0004 25303364 	 .ascii "%03dV %03dA %03dkm/h\000"
 1472      56202530 
 1472      33644120 
 1472      25303364 
 1472      6B6D2F68 
 1473              	 .global __aeabi_f2d
 1474 0019 000000   	 .align 2
 1475              	.LC3:
 1476 001c 25303464 	 .ascii "%04d %04d %04d %02.1f\000"
 1476      20253034 
 1476      64202530 
 1476      34642025 
 1476      30322E31 
 1477 0032 0000     	 .align 2
 1478              	.LC4:
 1479 0034 25303464 	 .ascii "%04d %04d %04d %05d\000"
 1479      20253034 
 1479      64202530 
 1479      34642025 
 1479      30356400 
 1480              	 .section .text.UpdateLCD,"ax",%progbits
 1481              	 .align 2
 1482              	 .global UpdateLCD
 1483              	 .thumb
 1484              	 .thumb_func
 1486              	UpdateLCD:
 1487              	.LFB437:
 389:../main.c     **** 
 390:../main.c     **** 
 391:../main.c     **** void UpdateLCD(void)
 392:../main.c     **** {
 1488              	 .loc 2 392 0
 1489              	 .cfi_startproc
 1490              	 
 1491              	 
 1492 0000 90B5     	 push {r4,r7,lr}
 1493              	.LCFI32:
 1494              	 .cfi_def_cfa_offset 12
 1495              	 .cfi_offset 4,-12
 1496              	 .cfi_offset 7,-8
 1497              	 .cfi_offset 14,-4
 1498 0002 2DED028B 	 fstmfdd sp!,{d8}
 1499              	.LCFI33:
 1500              	 .cfi_def_cfa_offset 20
 1501              	 .cfi_offset 80,-20
 1502              	 .cfi_offset 81,-16
 1503 0006 8DB0     	 sub sp,sp,#52
 1504              	.LCFI34:
 1505              	 .cfi_def_cfa_offset 72
 1506 0008 04AF     	 add r7,sp,#16
 1507              	.LCFI35:
 1508              	 .cfi_def_cfa 7,56
 393:../main.c     **** 	char temp[30];
 394:../main.c     **** 	RTC_GetTime(&current_time);
 1509              	 .loc 2 394 0
 1510 000a 6648     	 ldr r0,.L77
 1511 000c FFF7FEFF 	 bl RTC_GetTime
 395:../main.c     **** 
 396:../main.c     **** 	LCDWriteCommand(0x0E); // clear the screen
 1512              	 .loc 2 396 0
 1513 0010 0E20     	 movs r0,#14
 1514 0012 FFF7FEFF 	 bl LCDWriteCommand
 397:../main.c     **** 	sprintf(temp, "%03dV %03dA %03dkm/h", (int)smartdata.battVolt,(int)smartdata.battAmp,smartdata.vel
 1515              	 .loc 2 397 0
 1516 0016 644B     	 ldr r3,.L77+4
 1517 0018 D3ED027A 	 flds s15,[r3,#8]
 1518 001c BDEEE77A 	 ftosizs s14,s15
 1519 0020 614B     	 ldr r3,.L77+4
 1520 0022 D3ED017A 	 flds s15,[r3,#4]
 1521 0026 FDEEE77A 	 ftosizs s15,s15
 1522 002a 5F4B     	 ldr r3,.L77+4
 1523 002c 1B88     	 ldrh r3,[r3]
 1524 002e 1A46     	 mov r2,r3
 1525 0030 3B46     	 mov r3,r7
 1526 0032 0092     	 str r2,[sp]
 1527 0034 1846     	 mov r0,r3
 1528 0036 5D49     	 ldr r1,.L77+8
 1529 0038 17EE102A 	 fmrs r2,s14
 1530 003c 17EE903A 	 fmrs r3,s15
 1531 0040 FFF7FEFF 	 bl sprintf
 398:../main.c     **** 	LCDCursorXY(0, 0);
 1532              	 .loc 2 398 0
 1533 0044 0020     	 movs r0,#0
 1534 0046 0021     	 movs r1,#0
 1535 0048 FFF7FEFF 	 bl LCDCursorXY
 399:../main.c     **** 	LCDWriteString(temp);
 1536              	 .loc 2 399 0
 1537 004c 3B46     	 mov r3,r7
 1538 004e 1846     	 mov r0,r3
 1539 0050 FFF7FEFF 	 bl LCDWriteString
 400:../main.c     **** 
 401:../main.c     **** 	sprintf(temp,"%04d %04d %04d %02.1f",(int)(smartdata.temps[0]*10),(int)(smartdata.temps[1]*10),(in
 1540              	 .loc 2 401 0
 1541 0054 544B     	 ldr r3,.L77+4
 1542 0056 D3ED0B7A 	 flds s15,[r3,#44]
 1543 005a B2EE047A 	 fconsts s14,#36
 1544 005e 67EE877A 	 fmuls s15,s15,s14
 1545 0062 FDEEE78A 	 ftosizs s17,s15
 1546 0066 504B     	 ldr r3,.L77+4
 1547 0068 D3ED0C7A 	 flds s15,[r3,#48]
 1548 006c B2EE047A 	 fconsts s14,#36
 1549 0070 67EE877A 	 fmuls s15,s15,s14
 1550 0074 BDEEE78A 	 ftosizs s16,s15
 1551 0078 4B4B     	 ldr r3,.L77+4
 1552 007a D3ED0D7A 	 flds s15,[r3,#52]
 1553 007e B2EE047A 	 fconsts s14,#36
 1554 0082 67EE877A 	 fmuls s15,s15,s14
 1555 0086 FDEEE77A 	 ftosizs s15,s15
 1556 008a 17EE904A 	 fmrs r4,s15
 1557 008e 464B     	 ldr r3,.L77+4
 1558 0090 DB68     	 ldr r3,[r3,#12]
 1559 0092 1846     	 mov r0,r3
 1560 0094 FFF7FEFF 	 bl __aeabi_f2d
 1561 0098 0246     	 mov r2,r0
 1562 009a 0B46     	 mov r3,r1
 1563 009c 3946     	 mov r1,r7
 1564 009e 0094     	 str r4,[sp]
 1565 00a0 CDE90223 	 strd r2,[sp,#8]
 1566 00a4 0846     	 mov r0,r1
 1567 00a6 4249     	 ldr r1,.L77+12
 1568 00a8 18EE902A 	 fmrs r2,s17
 1569 00ac 18EE103A 	 fmrs r3,s16
 1570 00b0 FFF7FEFF 	 bl sprintf
 402:../main.c     **** 	LCDCursorXY(1, 0);
 1571              	 .loc 2 402 0
 1572 00b4 0120     	 movs r0,#1
 1573 00b6 0021     	 movs r1,#0
 1574 00b8 FFF7FEFF 	 bl LCDCursorXY
 403:../main.c     **** 	LCDWriteString(temp);
 1575              	 .loc 2 403 0
 1576 00bc 3B46     	 mov r3,r7
 1577 00be 1846     	 mov r0,r3
 1578 00c0 FFF7FEFF 	 bl LCDWriteString
 404:../main.c     **** 
 405:../main.c     **** 	sprintf(temp,"%04d %04d %04d %02.1f",(int)(smartdata.temps[3]*10),(int)(smartdata.temps[4]*10),(in
 1579              	 .loc 2 405 0
 1580 00c4 384B     	 ldr r3,.L77+4
 1581 00c6 D3ED0E7A 	 flds s15,[r3,#56]
 1582 00ca B2EE047A 	 fconsts s14,#36
 1583 00ce 67EE877A 	 fmuls s15,s15,s14
 1584 00d2 FDEEE78A 	 ftosizs s17,s15
 1585 00d6 344B     	 ldr r3,.L77+4
 1586 00d8 D3ED0F7A 	 flds s15,[r3,#60]
 1587 00dc B2EE047A 	 fconsts s14,#36
 1588 00e0 67EE877A 	 fmuls s15,s15,s14
 1589 00e4 BDEEE78A 	 ftosizs s16,s15
 1590 00e8 2F4B     	 ldr r3,.L77+4
 1591 00ea D3ED107A 	 flds s15,[r3,#64]
 1592 00ee B2EE047A 	 fconsts s14,#36
 1593 00f2 67EE877A 	 fmuls s15,s15,s14
 1594 00f6 FDEEE77A 	 ftosizs s15,s15
 1595 00fa 17EE904A 	 fmrs r4,s15
 1596 00fe 2A4B     	 ldr r3,.L77+4
 1597 0100 1B69     	 ldr r3,[r3,#16]
 1598 0102 1846     	 mov r0,r3
 1599 0104 FFF7FEFF 	 bl __aeabi_f2d
 1600 0108 0246     	 mov r2,r0
 1601 010a 0B46     	 mov r3,r1
 1602 010c 3946     	 mov r1,r7
 1603 010e 0094     	 str r4,[sp]
 1604 0110 CDE90223 	 strd r2,[sp,#8]
 1605 0114 0846     	 mov r0,r1
 1606 0116 2649     	 ldr r1,.L77+12
 1607 0118 18EE902A 	 fmrs r2,s17
 1608 011c 18EE103A 	 fmrs r3,s16
 1609 0120 FFF7FEFF 	 bl sprintf
 406:../main.c     **** 	LCDCursorXY(2, 0);
 1610              	 .loc 2 406 0
 1611 0124 0220     	 movs r0,#2
 1612 0126 0021     	 movs r1,#0
 1613 0128 FFF7FEFF 	 bl LCDCursorXY
 407:../main.c     **** 	LCDWriteString(temp);
 1614              	 .loc 2 407 0
 1615 012c 3B46     	 mov r3,r7
 1616 012e 1846     	 mov r0,r3
 1617 0130 FFF7FEFF 	 bl LCDWriteString
 408:../main.c     **** 
 409:../main.c     **** 	sprintf(temp,"%04d %04d %04d %05d",(int)(smartdata.temps[6]*10),(int)(smartdata.temps[7]*10),(int)
 1618              	 .loc 2 409 0
 1619 0134 1C4B     	 ldr r3,.L77+4
 1620 0136 D3ED117A 	 flds s15,[r3,#68]
 1621 013a B2EE047A 	 fconsts s14,#36
 1622 013e 67EE877A 	 fmuls s15,s15,s14
 1623 0142 BDEEE76A 	 ftosizs s12,s15
 1624 0146 184B     	 ldr r3,.L77+4
 1625 0148 D3ED127A 	 flds s15,[r3,#72]
 1626 014c B2EE047A 	 fconsts s14,#36
 1627 0150 67EE877A 	 fmuls s15,s15,s14
 1628 0154 FDEEE76A 	 ftosizs s13,s15
 1629 0158 134B     	 ldr r3,.L77+4
 1630 015a D3ED137A 	 flds s15,[r3,#76]
 1631 015e B2EE047A 	 fconsts s14,#36
 1632 0162 67EE877A 	 fmuls s15,s15,s14
 1633 0166 FDEEE77A 	 ftosizs s15,s15
 1634 016a 17EE901A 	 fmrs r1,s15
 1635 016e 114B     	 ldr r3,.L77+16
 1636 0170 1B68     	 ldr r3,[r3]
 1637 0172 1A46     	 mov r2,r3
 1638 0174 3B46     	 mov r3,r7
 1639 0176 0091     	 str r1,[sp]
 1640 0178 0192     	 str r2,[sp,#4]
 1641 017a 1846     	 mov r0,r3
 1642 017c 0E49     	 ldr r1,.L77+20
 1643 017e 16EE102A 	 fmrs r2,s12
 1644 0182 16EE903A 	 fmrs r3,s13
 1645 0186 FFF7FEFF 	 bl sprintf
 410:../main.c     **** 	LCDCursorXY(3, 0);
 1646              	 .loc 2 410 0
 1647 018a 0320     	 movs r0,#3
 1648 018c 0021     	 movs r1,#0
 1649 018e FFF7FEFF 	 bl LCDCursorXY
 411:../main.c     **** 	LCDWriteString(temp);
 1650              	 .loc 2 411 0
 1651 0192 3B46     	 mov r3,r7
 1652 0194 1846     	 mov r0,r3
 1653 0196 FFF7FEFF 	 bl LCDWriteString
 412:../main.c     **** 
 413:../main.c     **** 	//XMC_RTC_GetTime(&current_time);
 414:../main.c     **** 	//LCDCursorXY(3, 0);
 415:../main.c     **** 	//sprintf(temp, "%04d/%02d/%02d %02d:%02d:%02d",current_time.year,current_time.month,current_time.
 416:../main.c     **** 	//LCDWriteString(temp);
 417:../main.c     **** 
 418:../main.c     **** 
 419:../main.c     **** 	/*
 420:../main.c     **** 	sprintf(temp, "%02d/%02d/%02d/%02d/%02d",current_time.days,current_time.month,current_time.hours,c
 421:../main.c     **** 	LCDWriteString(temp);
 422:../main.c     **** 	LCDCursorXY(3, 0);
 423:../main.c     **** 	sprintf(temp, "%03dV %03dA %03dkM", (int)smartdata.battVolt,(int)smartdata.battAmp,smartdata.veloc
 424:../main.c     **** 	LCDWriteString(temp);
 425:../main.c     **** 	*/
 426:../main.c     **** }
 1654              	 .loc 2 426 0
 1655 019a 2437     	 adds r7,r7,#36
 1656              	.LCFI36:
 1657              	 .cfi_def_cfa_offset 20
 1658 019c BD46     	 mov sp,r7
 1659              	.LCFI37:
 1660              	 .cfi_def_cfa_register 13
 1661              	 
 1662 019e BDEC028B 	 fldmfdd sp!,{d8}
 1663              	.LCFI38:
 1664              	 .cfi_restore 80
 1665              	 .cfi_restore 81
 1666              	 .cfi_def_cfa_offset 12
 1667 01a2 90BD     	 pop {r4,r7,pc}
 1668              	.L78:
 1669              	 .align 2
 1670              	.L77:
 1671 01a4 00000000 	 .word current_time
 1672 01a8 00000000 	 .word smartdata
 1673 01ac 04000000 	 .word .LC2
 1674 01b0 1C000000 	 .word .LC3
 1675 01b4 00000000 	 .word sampleCounter
 1676 01b8 34000000 	 .word .LC4
 1677              	 .cfi_endproc
 1678              	.LFE437:
 1680              	 .section .rodata
 1681              	 .align 2
 1682              	.LC5:
 1683 0048 25303464 	 .ascii "%04d %02d %02d\000"
 1683      20253032 
 1683      64202530 
 1683      326400
 1684 0057 00       	 .align 2
 1685              	.LC6:
 1686 0058 25303264 	 .ascii "%02d %02d %02d:%05d:\000"
 1686      20253032 
 1686      64202530 
 1686      32643A25 
 1686      3035643A 
 1687 006d 000000   	 .align 2
 1688              	.LC7:
 1689 0070 25735F64 	 .ascii "%s_data_erhan.txt\000"
 1689      6174615F 
 1689      65726861 
 1689      6E2E7478 
 1689      7400
 1690 0082 0000     	 .align 2
 1691              	.LC8:
 1692 0084 2530332E 	 .ascii "%03.2f:%03.2f:%03d:%03.2f\012\000"
 1692      32663A25 
 1692      30332E32 
 1692      663A2530 
 1692      33643A25 
 1693 009f 00       	 .align 2
 1694              	.LC9:
 1695 00a0 25735F74 	 .ascii "%s_temp_erhan.txt\000"
 1695      656D705F 
 1695      65726861 
 1695      6E2E7478 
 1695      7400
 1696 00b2 0000     	 .align 2
 1697              	.LC10:
 1698 00b4 2530332E 	 .ascii "%03.2f:\000"
 1698      32663A00 
 1699              	 .align 2
 1700              	.LC11:
 1701 00bc 2530332E 	 .ascii "%03.2f\000"
 1701      326600
 1702 00c3 00       	 .align 2
 1703              	.LC12:
 1704 00c4 0A00     	 .ascii "\012\000"
 1705              	 .section .text.UpdateSDCard,"ax",%progbits
 1706              	 .align 2
 1707              	 .global UpdateSDCard
 1708              	 .thumb
 1709              	 .thumb_func
 1711              	UpdateSDCard:
 1712              	.LFB438:
 427:../main.c     **** 
 428:../main.c     **** void UpdateSDCard(void)
 429:../main.c     **** {
 1713              	 .loc 2 429 0
 1714              	 .cfi_startproc
 1715              	 
 1716              	 
 1717 0000 2DE9F043 	 push {r4,r5,r6,r7,r8,r9,lr}
 1718              	.LCFI39:
 1719              	 .cfi_def_cfa_offset 28
 1720              	 .cfi_offset 4,-28
 1721              	 .cfi_offset 5,-24
 1722              	 .cfi_offset 6,-20
 1723              	 .cfi_offset 7,-16
 1724              	 .cfi_offset 8,-12
 1725              	 .cfi_offset 9,-8
 1726              	 .cfi_offset 14,-4
 1727 0004 ADF50D7D 	 sub sp,sp,#564
 1728              	.LCFI40:
 1729              	 .cfi_def_cfa_offset 592
 1730 0008 06AF     	 add r7,sp,#24
 1731              	.LCFI41:
 1732              	 .cfi_def_cfa 7,568
 430:../main.c     **** 	char dateString[32];
 431:../main.c     **** 	char timeString[32];
 432:../main.c     **** 	char dataString[64];
 433:../main.c     **** 	//char cellVoltagesString[5*93+20];
 434:../main.c     **** 	char tempString[128];
 435:../main.c     **** 	char tempFileNmaeString[64];
 436:../main.c     **** 	char battFileNmaeString[64];
 437:../main.c     **** 	//char cellVotlageFileNameString[64];
 438:../main.c     **** 	char temp[16];
 439:../main.c     **** 	char dataTimeString[128];
 440:../main.c     **** 	uint8_t erhan;
 441:../main.c     **** 	RTC_GetTime(&current_time);
 1733              	 .loc 2 441 0
 1734 000a 7B48     	 ldr r0,.L82
 1735 000c FFF7FEFF 	 bl RTC_GetTime
 442:../main.c     **** 	sprintf(dateString,"%04d %02d %02d",current_time.year,current_time.month,current_time.days);
 1736              	 .loc 2 442 0
 1737 0010 794B     	 ldr r3,.L82
 1738 0012 DB88     	 ldrh r3,[r3,#6]
 1739 0014 1D46     	 mov r5,r3
 1740 0016 784B     	 ldr r3,.L82
 1741 0018 5B79     	 ldrb r3,[r3,#5]
 1742 001a C3F30303 	 ubfx r3,r3,#0,#4
 1743 001e DBB2     	 uxtb r3,r3
 1744 0020 1C46     	 mov r4,r3
 1745 0022 754B     	 ldr r3,.L82
 1746 0024 DB78     	 ldrb r3,[r3,#3]
 1747 0026 C3F30403 	 ubfx r3,r3,#0,#5
 1748 002a DBB2     	 uxtb r3,r3
 1749 002c 1A46     	 mov r2,r3
 1750 002e 07F5FA73 	 add r3,r7,#500
 1751 0032 0092     	 str r2,[sp]
 1752 0034 1846     	 mov r0,r3
 1753 0036 7149     	 ldr r1,.L82+4
 1754 0038 2A46     	 mov r2,r5
 1755 003a 2346     	 mov r3,r4
 1756 003c FFF7FEFF 	 bl sprintf
 443:../main.c     **** 	sprintf(timeString,"%02d %02d %02d:%05d:",current_time.hours,current_time.minutes,current_time.sec
 1757              	 .loc 2 443 0
 1758 0040 6D4B     	 ldr r3,.L82
 1759 0042 9B78     	 ldrb r3,[r3,#2]
 1760 0044 C3F30403 	 ubfx r3,r3,#0,#5
 1761 0048 DBB2     	 uxtb r3,r3
 1762 004a 1D46     	 mov r5,r3
 1763 004c 6A4B     	 ldr r3,.L82
 1764 004e 5B78     	 ldrb r3,[r3,#1]
 1765 0050 C3F30503 	 ubfx r3,r3,#0,#6
 1766 0054 DBB2     	 uxtb r3,r3
 1767 0056 1C46     	 mov r4,r3
 1768 0058 674B     	 ldr r3,.L82
 1769 005a 1B78     	 ldrb r3,[r3]
 1770 005c C3F30503 	 ubfx r3,r3,#0,#6
 1771 0060 DBB2     	 uxtb r3,r3
 1772 0062 1946     	 mov r1,r3
 1773 0064 664B     	 ldr r3,.L82+8
 1774 0066 1B68     	 ldr r3,[r3]
 1775 0068 07F5EA72 	 add r2,r7,#468
 1776 006c 0091     	 str r1,[sp]
 1777 006e 0193     	 str r3,[sp,#4]
 1778 0070 1046     	 mov r0,r2
 1779 0072 6449     	 ldr r1,.L82+12
 1780 0074 2A46     	 mov r2,r5
 1781 0076 2346     	 mov r3,r4
 1782 0078 FFF7FEFF 	 bl sprintf
 444:../main.c     **** 
 445:../main.c     **** 	sprintf(battFileNmaeString,"%s_data_erhan.txt",dateString);
 1783              	 .loc 2 445 0
 1784 007c 07F19402 	 add r2,r7,#148
 1785 0080 07F5FA73 	 add r3,r7,#500
 1786 0084 1046     	 mov r0,r2
 1787 0086 6049     	 ldr r1,.L82+16
 1788 0088 1A46     	 mov r2,r3
 1789 008a FFF7FEFF 	 bl sprintf
 446:../main.c     **** 	sprintf(dataString,"%03.2f:%03.2f:%03d:%03.2f\n",smartdata.battVolt,smartdata.battAmp,smartdata.ve
 1790              	 .loc 2 446 0
 1791 008e 5F4B     	 ldr r3,.L82+20
 1792 0090 9B68     	 ldr r3,[r3,#8]
 1793 0092 1846     	 mov r0,r3
 1794 0094 FFF7FEFF 	 bl __aeabi_f2d
 1795 0098 8046     	 mov r8,r0
 1796 009a 8946     	 mov r9,r1
 1797 009c 5B4B     	 ldr r3,.L82+20
 1798 009e 5B68     	 ldr r3,[r3,#4]
 1799 00a0 1846     	 mov r0,r3
 1800 00a2 FFF7FEFF 	 bl __aeabi_f2d
 1801 00a6 0446     	 mov r4,r0
 1802 00a8 0D46     	 mov r5,r1
 1803 00aa 584B     	 ldr r3,.L82+20
 1804 00ac 1B88     	 ldrh r3,[r3]
 1805 00ae 1E46     	 mov r6,r3
 1806 00b0 564B     	 ldr r3,.L82+20
 1807 00b2 5B69     	 ldr r3,[r3,#20]
 1808 00b4 1846     	 mov r0,r3
 1809 00b6 FFF7FEFF 	 bl __aeabi_f2d
 1810 00ba 0246     	 mov r2,r0
 1811 00bc 0B46     	 mov r3,r1
 1812 00be 07F5CA71 	 add r1,r7,#404
 1813 00c2 CDE90045 	 strd r4,[sp]
 1814 00c6 0296     	 str r6,[sp,#8]
 1815 00c8 CDE90423 	 strd r2,[sp,#16]
 1816 00cc 0846     	 mov r0,r1
 1817 00ce 5049     	 ldr r1,.L82+24
 1818 00d0 4246     	 mov r2,r8
 1819 00d2 4B46     	 mov r3,r9
 1820 00d4 FFF7FEFF 	 bl sprintf
 447:../main.c     **** 	strcpy(dataTimeString,timeString);
 1821              	 .loc 2 447 0
 1822 00d8 3A1D     	 adds r2,r7,#4
 1823 00da 07F5EA73 	 add r3,r7,#468
 1824 00de 1046     	 mov r0,r2
 1825 00e0 1946     	 mov r1,r3
 1826 00e2 FFF7FEFF 	 bl strcpy
 448:../main.c     **** 	strcat(dataTimeString,dataString);
 1827              	 .loc 2 448 0
 1828 00e6 3A1D     	 adds r2,r7,#4
 1829 00e8 07F5CA73 	 add r3,r7,#404
 1830 00ec 1046     	 mov r0,r2
 1831 00ee 1946     	 mov r1,r3
 1832 00f0 FFF7FEFF 	 bl strcat
 449:../main.c     **** 	writeToEndOfFile(&FatFs, &Fil,battFileNmaeString, dataTimeString,strlen(dataTimeString));
 1833              	 .loc 2 449 0
 1834 00f4 3B1D     	 adds r3,r7,#4
 1835 00f6 1846     	 mov r0,r3
 1836 00f8 FFF7FEFF 	 bl strlen
 1837 00fc 0146     	 mov r1,r0
 1838 00fe 07F19402 	 add r2,r7,#148
 1839 0102 3B1D     	 adds r3,r7,#4
 1840 0104 0091     	 str r1,[sp]
 1841 0106 4348     	 ldr r0,.L82+28
 1842 0108 4349     	 ldr r1,.L82+32
 1843 010a FFF7FEFF 	 bl writeToEndOfFile
 450:../main.c     **** /*
 451:../main.c     **** 	if(cellVoltagesUpdated)
 452:../main.c     **** 	{
 453:../main.c     **** 		// Reverse MSB and LSB bytes in the cell voltages to represent it in 16bits and print on the CLI.
 454:../main.c     **** 		for (uint8_t erhan2 = 0; erhan2 < CELL_VOLTAGES_DATA_FLOW_COUNT*28+2; erhan2++)
 455:../main.c     **** 		{
 456:../main.c     **** 			erhan = smartdata.cellVotlagesBytes[2*erhan2];
 457:../main.c     **** 			smartdata.cellVotlagesBytes[2*erhan2] = smartdata.cellVotlagesBytes[2*erhan2+1];
 458:../main.c     **** 			smartdata.cellVotlagesBytes[2*erhan2+1] = erhan;
 459:../main.c     **** 		}
 460:../main.c     **** 
 461:../main.c     **** 		sprintf(cellVotlageFileNameString,"%s_cell_voltages_erhan.txt",dateString);
 462:../main.c     **** 		strcpy(cellVoltagesString,timeString);
 463:../main.c     **** 		for(erhan = 0; erhan < CELL_COUNTS; erhan++)
 464:../main.c     **** 		{
 465:../main.c     **** 			sprintf(temp,"%04d:",smartdata.cellVoltages[erhan]);
 466:../main.c     **** 			strcat(cellVoltagesString,temp);
 467:../main.c     **** 		}
 468:../main.c     **** 		strcat(cellVoltagesString,"\n");
 469:../main.c     **** 		writeToEndOfFile(&FatFs, &Fil,cellVotlageFileNameString, cellVoltagesString,strlen(cellVoltagesSt
 470:../main.c     **** 		cellVoltagesUpdated = 0;
 471:../main.c     **** 	}
 472:../main.c     **** */
 473:../main.c     **** 	sprintf(tempFileNmaeString,"%s_temp_erhan.txt",dateString);
 1844              	 .loc 2 473 0
 1845 010e 07F1D402 	 add r2,r7,#212
 1846 0112 07F5FA73 	 add r3,r7,#500
 1847 0116 1046     	 mov r0,r2
 1848 0118 4049     	 ldr r1,.L82+36
 1849 011a 1A46     	 mov r2,r3
 1850 011c FFF7FEFF 	 bl sprintf
 474:../main.c     **** 	strcpy(tempString,timeString);
 1851              	 .loc 2 474 0
 1852 0120 07F58A72 	 add r2,r7,#276
 1853 0124 07F5EA73 	 add r3,r7,#468
 1854 0128 1046     	 mov r0,r2
 1855 012a 1946     	 mov r1,r3
 1856 012c FFF7FEFF 	 bl strcpy
 475:../main.c     **** 	for (erhan = 0; erhan < 8; erhan++)
 1857              	 .loc 2 475 0
 1858 0130 0023     	 movs r3,#0
 1859 0132 87F81732 	 strb r3,[r7,#535]
 1860 0136 20E0     	 b .L80
 1861              	.L81:
 476:../main.c     **** 	{
 477:../main.c     **** 		sprintf(temp,"%03.2f:",smartdata.temps[erhan]);
 1862              	 .loc 2 477 0 discriminator 3
 1863 0138 97F81732 	 ldrb r3,[r7,#535]
 1864 013c 334A     	 ldr r2,.L82+20
 1865 013e 0A33     	 adds r3,r3,#10
 1866 0140 9B00     	 lsls r3,r3,#2
 1867 0142 1344     	 add r3,r3,r2
 1868 0144 5B68     	 ldr r3,[r3,#4]
 1869 0146 1846     	 mov r0,r3
 1870 0148 FFF7FEFF 	 bl __aeabi_f2d
 1871 014c 0446     	 mov r4,r0
 1872 014e 0D46     	 mov r5,r1
 1873 0150 07F18403 	 add r3,r7,#132
 1874 0154 1846     	 mov r0,r3
 1875 0156 3249     	 ldr r1,.L82+40
 1876 0158 2246     	 mov r2,r4
 1877 015a 2B46     	 mov r3,r5
 1878 015c FFF7FEFF 	 bl sprintf
 478:../main.c     **** 		strcat(tempString,temp);
 1879              	 .loc 2 478 0 discriminator 3
 1880 0160 07F58A72 	 add r2,r7,#276
 1881 0164 07F18403 	 add r3,r7,#132
 1882 0168 1046     	 mov r0,r2
 1883 016a 1946     	 mov r1,r3
 1884 016c FFF7FEFF 	 bl strcat
 475:../main.c     **** 	for (erhan = 0; erhan < 8; erhan++)
 1885              	 .loc 2 475 0 discriminator 3
 1886 0170 97F81732 	 ldrb r3,[r7,#535]
 1887 0174 0133     	 adds r3,r3,#1
 1888 0176 87F81732 	 strb r3,[r7,#535]
 1889              	.L80:
 475:../main.c     **** 	for (erhan = 0; erhan < 8; erhan++)
 1890              	 .loc 2 475 0 is_stmt 0 discriminator 1
 1891 017a 97F81732 	 ldrb r3,[r7,#535]
 1892 017e 072B     	 cmp r3,#7
 1893 0180 DAD9     	 bls .L81
 479:../main.c     **** 	}
 480:../main.c     **** 	sprintf(temp,"%03.2f",smartdata.temps[8]);
 1894              	 .loc 2 480 0 is_stmt 1
 1895 0182 224B     	 ldr r3,.L82+20
 1896 0184 DB6C     	 ldr r3,[r3,#76]
 1897 0186 1846     	 mov r0,r3
 1898 0188 FFF7FEFF 	 bl __aeabi_f2d
 1899 018c 0446     	 mov r4,r0
 1900 018e 0D46     	 mov r5,r1
 1901 0190 07F18403 	 add r3,r7,#132
 1902 0194 1846     	 mov r0,r3
 1903 0196 2349     	 ldr r1,.L82+44
 1904 0198 2246     	 mov r2,r4
 1905 019a 2B46     	 mov r3,r5
 1906 019c FFF7FEFF 	 bl sprintf
 481:../main.c     **** 	strcat(tempString,temp);
 1907              	 .loc 2 481 0
 1908 01a0 07F58A72 	 add r2,r7,#276
 1909 01a4 07F18403 	 add r3,r7,#132
 1910 01a8 1046     	 mov r0,r2
 1911 01aa 1946     	 mov r1,r3
 1912 01ac FFF7FEFF 	 bl strcat
 482:../main.c     **** 	strcat(tempString,"\n");
 1913              	 .loc 2 482 0
 1914 01b0 07F58A73 	 add r3,r7,#276
 1915 01b4 1846     	 mov r0,r3
 1916 01b6 FFF7FEFF 	 bl strlen
 1917 01ba 0346     	 mov r3,r0
 1918 01bc 1A46     	 mov r2,r3
 1919 01be 07F58A73 	 add r3,r7,#276
 1920 01c2 1344     	 add r3,r3,r2
 1921 01c4 1849     	 ldr r1,.L82+48
 1922 01c6 1A46     	 mov r2,r3
 1923 01c8 0B46     	 mov r3,r1
 1924 01ca 1B88     	 ldrh r3,[r3]
 1925 01cc 1380     	 strh r3,[r2]
 483:../main.c     **** 	writeToEndOfFile(&FatFs, &Fil,tempFileNmaeString, tempString,strlen(tempString));
 1926              	 .loc 2 483 0
 1927 01ce 07F58A73 	 add r3,r7,#276
 1928 01d2 1846     	 mov r0,r3
 1929 01d4 FFF7FEFF 	 bl strlen
 1930 01d8 0146     	 mov r1,r0
 1931 01da 07F1D402 	 add r2,r7,#212
 1932 01de 07F58A73 	 add r3,r7,#276
 1933 01e2 0091     	 str r1,[sp]
 1934 01e4 0B48     	 ldr r0,.L82+28
 1935 01e6 0C49     	 ldr r1,.L82+32
 1936 01e8 FFF7FEFF 	 bl writeToEndOfFile
 484:../main.c     **** 
 485:../main.c     ****  }
 1937              	 .loc 2 485 0
 1938 01ec 07F50777 	 add r7,r7,#540
 1939              	.LCFI42:
 1940              	 .cfi_def_cfa_offset 28
 1941 01f0 BD46     	 mov sp,r7
 1942              	.LCFI43:
 1943              	 .cfi_def_cfa_register 13
 1944              	 
 1945 01f2 BDE8F083 	 pop {r4,r5,r6,r7,r8,r9,pc}
 1946              	.L83:
 1947 01f6 00BF     	 .align 2
 1948              	.L82:
 1949 01f8 00000000 	 .word current_time
 1950 01fc 48000000 	 .word .LC5
 1951 0200 00000000 	 .word sampleCounter
 1952 0204 58000000 	 .word .LC6
 1953 0208 70000000 	 .word .LC7
 1954 020c 00000000 	 .word smartdata
 1955 0210 84000000 	 .word .LC8
 1956 0214 00000000 	 .word FatFs
 1957 0218 00000000 	 .word Fil
 1958 021c A0000000 	 .word .LC9
 1959 0220 B4000000 	 .word .LC10
 1960 0224 BC000000 	 .word .LC11
 1961 0228 C4000000 	 .word .LC12
 1962              	 .cfi_endproc
 1963              	.LFE438:
 1965              	 .section .text.isLeapYear,"ax",%progbits
 1966              	 .align 2
 1967              	 .global isLeapYear
 1968              	 .thumb
 1969              	 .thumb_func
 1971              	isLeapYear:
 1972              	.LFB439:
 486:../main.c     **** 
 487:../main.c     **** uint8_t isLeapYear(uint32_t year)
 488:../main.c     **** {
 1973              	 .loc 2 488 0
 1974              	 .cfi_startproc
 1975              	 
 1976              	 
 1977              	 
 1978 0000 80B4     	 push {r7}
 1979              	.LCFI44:
 1980              	 .cfi_def_cfa_offset 4
 1981              	 .cfi_offset 7,-4
 1982 0002 83B0     	 sub sp,sp,#12
 1983              	.LCFI45:
 1984              	 .cfi_def_cfa_offset 16
 1985 0004 00AF     	 add r7,sp,#0
 1986              	.LCFI46:
 1987              	 .cfi_def_cfa_register 7
 1988 0006 7860     	 str r0,[r7,#4]
 489:../main.c     **** 	if (year%400 == 0) // Exactly divisible by 400 e.g. 1600, 2000
 1989              	 .loc 2 489 0
 1990 0008 7A68     	 ldr r2,[r7,#4]
 1991 000a 144B     	 ldr r3,.L89
 1992 000c A3FB0213 	 umull r1,r3,r3,r2
 1993 0010 DB09     	 lsrs r3,r3,#7
 1994 0012 4FF4C871 	 mov r1,#400
 1995 0016 01FB03F3 	 mul r3,r1,r3
 1996 001a D31A     	 subs r3,r2,r3
 1997 001c 002B     	 cmp r3,#0
 1998 001e 01D1     	 bne .L85
 490:../main.c     **** 	  return 1;
 1999              	 .loc 2 490 0
 2000 0020 0123     	 movs r3,#1
 2001 0022 14E0     	 b .L86
 2002              	.L85:
 491:../main.c     **** 	else if (year%100 == 0) // Exactly divisible by 100 and not by 400 e.g. 1900, 2100
 2003              	 .loc 2 491 0
 2004 0024 7A68     	 ldr r2,[r7,#4]
 2005 0026 0D4B     	 ldr r3,.L89
 2006 0028 A3FB0213 	 umull r1,r3,r3,r2
 2007 002c 5B09     	 lsrs r3,r3,#5
 2008 002e 6421     	 movs r1,#100
 2009 0030 01FB03F3 	 mul r3,r1,r3
 2010 0034 D31A     	 subs r3,r2,r3
 2011 0036 002B     	 cmp r3,#0
 2012 0038 01D1     	 bne .L87
 492:../main.c     **** 	  return 0;
 2013              	 .loc 2 492 0
 2014 003a 0023     	 movs r3,#0
 2015 003c 07E0     	 b .L86
 2016              	.L87:
 493:../main.c     **** 	else if (year%4 == 0) // Exactly divisible by 4 and neither by 100 nor 400 e.g. 2016, 2020
 2017              	 .loc 2 493 0
 2018 003e 7B68     	 ldr r3,[r7,#4]
 2019 0040 03F00303 	 and r3,r3,#3
 2020 0044 002B     	 cmp r3,#0
 2021 0046 01D1     	 bne .L88
 494:../main.c     **** 	  return 1;
 2022              	 .loc 2 494 0
 2023 0048 0123     	 movs r3,#1
 2024 004a 00E0     	 b .L86
 2025              	.L88:
 495:../main.c     **** 	else // Not divisible by 4 or 100 or 400 e.g. 2017, 2018, 2019
 496:../main.c     **** 	  return 0;
 2026              	 .loc 2 496 0
 2027 004c 0023     	 movs r3,#0
 2028              	.L86:
 497:../main.c     **** }
 2029              	 .loc 2 497 0
 2030 004e 1846     	 mov r0,r3
 2031 0050 0C37     	 adds r7,r7,#12
 2032              	.LCFI47:
 2033              	 .cfi_def_cfa_offset 4
 2034 0052 BD46     	 mov sp,r7
 2035              	.LCFI48:
 2036              	 .cfi_def_cfa_register 13
 2037              	 
 2038 0054 5DF8047B 	 ldr r7,[sp],#4
 2039              	.LCFI49:
 2040              	 .cfi_restore 7
 2041              	 .cfi_def_cfa_offset 0
 2042 0058 7047     	 bx lr
 2043              	.L90:
 2044 005a 00BF     	 .align 2
 2045              	.L89:
 2046 005c 1F85EB51 	 .word 1374389535
 2047              	 .cfi_endproc
 2048              	.LFE439:
 2050              	 .section .rodata
 2051 00c6 0000     	 .align 2
 2052              	.LC13:
 2053 00c8 25303464 	 .ascii "%04d/%02d/%02d %02d:%02d:%02d\000"
 2053      2F253032 
 2053      642F2530 
 2053      32642025 
 2053      3032643A 
 2054 00e6 0000     	 .align 2
 2055              	.LC0:
 2056 00e8 1F       	 .byte 31
 2057 00e9 1C       	 .byte 28
 2058 00ea 1F       	 .byte 31
 2059 00eb 1E       	 .byte 30
 2060 00ec 1F       	 .byte 31
 2061 00ed 1E       	 .byte 30
 2062 00ee 1F       	 .byte 31
 2063 00ef 1F       	 .byte 31
 2064 00f0 1E       	 .byte 30
 2065 00f1 1F       	 .byte 31
 2066 00f2 1E       	 .byte 30
 2067 00f3 1F       	 .byte 31
 2068              	 .section .text.setTimer,"ax",%progbits
 2069              	 .align 2
 2070              	 .global setTimer
 2071              	 .thumb
 2072              	 .thumb_func
 2074              	setTimer:
 2075              	.LFB440:
 498:../main.c     **** 
 499:../main.c     **** void setTimer(void)
 500:../main.c     **** {
 2076              	 .loc 2 500 0
 2077              	 .cfi_startproc
 2078              	 
 2079              	 
 2080 0000 F0B5     	 push {r4,r5,r6,r7,lr}
 2081              	.LCFI50:
 2082              	 .cfi_def_cfa_offset 20
 2083              	 .cfi_offset 4,-20
 2084              	 .cfi_offset 5,-16
 2085              	 .cfi_offset 6,-12
 2086              	 .cfi_offset 7,-8
 2087              	 .cfi_offset 14,-4
 2088 0002 91B0     	 sub sp,sp,#68
 2089              	.LCFI51:
 2090              	 .cfi_def_cfa_offset 88
 2091 0004 04AF     	 add r7,sp,#16
 2092              	.LCFI52:
 2093              	 .cfi_def_cfa 7,72
 501:../main.c     **** 	uint8_t monthsSize[12]={31,28,31,30,31,30,31,31,30,31,30,31};
 2094              	 .loc 2 501 0
 2095 0006 A84A     	 ldr r2,.L113
 2096 0008 07F12003 	 add r3,r7,#32
 2097 000c 1068     	 ldr r0,[r2]
 2098 000e 5168     	 ldr r1,[r2,#4]
 2099 0010 9268     	 ldr r2,[r2,#8]
 2100 0012 07C3     	 stmia r3!,{r0,r1,r2}
 502:../main.c     **** 	uint16_t erhan;
 503:../main.c     **** 	char temp[26];
 504:../main.c     **** 	switch(setTimeMenu)
 2101              	 .loc 2 504 0
 2102 0014 A54B     	 ldr r3,.L113+4
 2103 0016 1B78     	 ldrb r3,[r3]
 2104 0018 072B     	 cmp r3,#7
 2105 001a 00F2CB82 	 bhi .L91
 2106 001e 01A2     	 adr r2,.L94
 2107 0020 52F823F0 	 ldr pc,[r2,r3,lsl#2]
 2108              	 .p2align 2
 2109              	.L94:
 2110 0024 B5050000 	 .word .L91+1
 2111 0028 45000000 	 .word .L95+1
 2112 002c 2B010000 	 .word .L96+1
 2113 0030 03020000 	 .word .L97+1
 2114 0034 D1020000 	 .word .L98+1
 2115 0038 E7030000 	 .word .L99+1
 2116 003c A5040000 	 .word .L100+1
 2117 0040 65050000 	 .word .L101+1
 2118              	 .p2align 1
 2119              	.L95:
 505:../main.c     **** 	{
 506:../main.c     **** 		case SET_TIME_IDLE:
 507:../main.c     **** 		break;
 508:../main.c     **** 
 509:../main.c     **** 		case SET_TIME_INIT:
 510:../main.c     **** 			set_time.year = current_time.year;
 2120              	 .loc 2 510 0
 2121 0044 9A4B     	 ldr r3,.L113+8
 2122 0046 DA88     	 ldrh r2,[r3,#6]
 2123 0048 9A4B     	 ldr r3,.L113+12
 2124 004a DA80     	 strh r2,[r3,#6]
 511:../main.c     **** 			set_time.month = current_time.month;
 2125              	 .loc 2 511 0
 2126 004c 984B     	 ldr r3,.L113+8
 2127 004e 5B79     	 ldrb r3,[r3,#5]
 2128 0050 C3F30303 	 ubfx r3,r3,#0,#4
 2129 0054 D9B2     	 uxtb r1,r3
 2130 0056 974A     	 ldr r2,.L113+12
 2131 0058 5379     	 ldrb r3,[r2,#5]
 2132 005a 61F30303 	 bfi r3,r1,#0,#4
 2133 005e 5371     	 strb r3,[r2,#5]
 512:../main.c     **** 			set_time.days = current_time.days;
 2134              	 .loc 2 512 0
 2135 0060 934B     	 ldr r3,.L113+8
 2136 0062 DB78     	 ldrb r3,[r3,#3]
 2137 0064 C3F30403 	 ubfx r3,r3,#0,#5
 2138 0068 D9B2     	 uxtb r1,r3
 2139 006a 924A     	 ldr r2,.L113+12
 2140 006c D378     	 ldrb r3,[r2,#3]
 2141 006e 61F30403 	 bfi r3,r1,#0,#5
 2142 0072 D370     	 strb r3,[r2,#3]
 513:../main.c     **** 			set_time.hours = current_time.hours;
 2143              	 .loc 2 513 0
 2144 0074 8E4B     	 ldr r3,.L113+8
 2145 0076 9B78     	 ldrb r3,[r3,#2]
 2146 0078 C3F30403 	 ubfx r3,r3,#0,#5
 2147 007c D9B2     	 uxtb r1,r3
 2148 007e 8D4A     	 ldr r2,.L113+12
 2149 0080 9378     	 ldrb r3,[r2,#2]
 2150 0082 61F30403 	 bfi r3,r1,#0,#5
 2151 0086 9370     	 strb r3,[r2,#2]
 514:../main.c     **** 			set_time.minutes = current_time.minutes;
 2152              	 .loc 2 514 0
 2153 0088 894B     	 ldr r3,.L113+8
 2154 008a 5B78     	 ldrb r3,[r3,#1]
 2155 008c C3F30503 	 ubfx r3,r3,#0,#6
 2156 0090 D9B2     	 uxtb r1,r3
 2157 0092 884A     	 ldr r2,.L113+12
 2158 0094 5378     	 ldrb r3,[r2,#1]
 2159 0096 61F30503 	 bfi r3,r1,#0,#6
 2160 009a 5370     	 strb r3,[r2,#1]
 515:../main.c     **** 			set_time.seconds = 0;
 2161              	 .loc 2 515 0
 2162 009c 854A     	 ldr r2,.L113+12
 2163 009e 1378     	 ldrb r3,[r2]
 2164 00a0 6FF30503 	 bfc r3,#0,#6
 2165 00a4 1370     	 strb r3,[r2]
 516:../main.c     **** 
 517:../main.c     **** 			LCDWriteCommand(0x01); // clear the screen
 2166              	 .loc 2 517 0
 2167 00a6 0120     	 movs r0,#1
 2168 00a8 FFF7FEFF 	 bl LCDWriteCommand
 518:../main.c     **** 			LCDCursorXY(0, 0);
 2169              	 .loc 2 518 0
 2170 00ac 0020     	 movs r0,#0
 2171 00ae 0021     	 movs r1,#0
 2172 00b0 FFF7FEFF 	 bl LCDCursorXY
 519:../main.c     **** 			sprintf(temp, "%04d/%02d/%02d %02d:%02d:%02d",set_time.year,set_time.days,set_time.month,set_tim
 2173              	 .loc 2 519 0
 2174 00b4 7F4B     	 ldr r3,.L113+12
 2175 00b6 DB88     	 ldrh r3,[r3,#6]
 2176 00b8 1E46     	 mov r6,r3
 2177 00ba 7E4B     	 ldr r3,.L113+12
 2178 00bc DB78     	 ldrb r3,[r3,#3]
 2179 00be C3F30403 	 ubfx r3,r3,#0,#5
 2180 00c2 DBB2     	 uxtb r3,r3
 2181 00c4 1D46     	 mov r5,r3
 2182 00c6 7B4B     	 ldr r3,.L113+12
 2183 00c8 5B79     	 ldrb r3,[r3,#5]
 2184 00ca C3F30303 	 ubfx r3,r3,#0,#4
 2185 00ce DBB2     	 uxtb r3,r3
 2186 00d0 1C46     	 mov r4,r3
 2187 00d2 784B     	 ldr r3,.L113+12
 2188 00d4 9B78     	 ldrb r3,[r3,#2]
 2189 00d6 C3F30403 	 ubfx r3,r3,#0,#5
 2190 00da DBB2     	 uxtb r3,r3
 2191 00dc 1846     	 mov r0,r3
 2192 00de 754B     	 ldr r3,.L113+12
 2193 00e0 5B78     	 ldrb r3,[r3,#1]
 2194 00e2 C3F30503 	 ubfx r3,r3,#0,#6
 2195 00e6 DBB2     	 uxtb r3,r3
 2196 00e8 1946     	 mov r1,r3
 2197 00ea 724B     	 ldr r3,.L113+12
 2198 00ec 1B78     	 ldrb r3,[r3]
 2199 00ee C3F30503 	 ubfx r3,r3,#0,#6
 2200 00f2 DBB2     	 uxtb r3,r3
 2201 00f4 1A46     	 mov r2,r3
 2202 00f6 3B1D     	 adds r3,r7,#4
 2203 00f8 0094     	 str r4,[sp]
 2204 00fa 0190     	 str r0,[sp,#4]
 2205 00fc 0291     	 str r1,[sp,#8]
 2206 00fe 0392     	 str r2,[sp,#12]
 2207 0100 1846     	 mov r0,r3
 2208 0102 6D49     	 ldr r1,.L113+16
 2209 0104 3246     	 mov r2,r6
 2210 0106 2B46     	 mov r3,r5
 2211 0108 FFF7FEFF 	 bl sprintf
 520:../main.c     **** 			LCDWriteString(temp);
 2212              	 .loc 2 520 0
 2213 010c 3B1D     	 adds r3,r7,#4
 2214 010e 1846     	 mov r0,r3
 2215 0110 FFF7FEFF 	 bl LCDWriteString
 521:../main.c     **** 			LCDCursorXY(0, 4);
 2216              	 .loc 2 521 0
 2217 0114 0020     	 movs r0,#0
 2218 0116 0421     	 movs r1,#4
 2219 0118 FFF7FEFF 	 bl LCDCursorXY
 522:../main.c     **** 			LCDWriteCommand(0x10);
 2220              	 .loc 2 522 0
 2221 011c 1020     	 movs r0,#16
 2222 011e FFF7FEFF 	 bl LCDWriteCommand
 523:../main.c     **** 			setTimeMenu = YEAR;
 2223              	 .loc 2 523 0
 2224 0122 624B     	 ldr r3,.L113+4
 2225 0124 0222     	 movs r2,#2
 2226 0126 1A70     	 strb r2,[r3]
 524:../main.c     **** 		break;
 2227              	 .loc 2 524 0
 2228 0128 44E2     	 b .L91
 2229              	.L96:
 525:../main.c     **** 
 526:../main.c     **** 		case YEAR:
 527:../main.c     **** 			if(button2Pressed)
 2230              	 .loc 2 527 0
 2231 012a 644B     	 ldr r3,.L113+20
 2232 012c 1B78     	 ldrb r3,[r3]
 2233 012e 002B     	 cmp r3,#0
 2234 0130 12D0     	 beq .L102
 528:../main.c     **** 			{
 529:../main.c     **** 				set_time.year++;
 2235              	 .loc 2 529 0
 2236 0132 604B     	 ldr r3,.L113+12
 2237 0134 DB88     	 ldrh r3,[r3,#6]
 2238 0136 0133     	 adds r3,r3,#1
 2239 0138 9AB2     	 uxth r2,r3
 2240 013a 5E4B     	 ldr r3,.L113+12
 2241 013c DA80     	 strh r2,[r3,#6]
 530:../main.c     **** 				if(set_time.year == 2100) set_time.year = 2000;
 2242              	 .loc 2 530 0
 2243 013e 5D4B     	 ldr r3,.L113+12
 2244 0140 DB88     	 ldrh r3,[r3,#6]
 2245 0142 40F63402 	 movw r2,#2100
 2246 0146 9342     	 cmp r3,r2
 2247 0148 03D1     	 bne .L103
 2248              	 .loc 2 530 0 is_stmt 0 discriminator 1
 2249 014a 5A4B     	 ldr r3,.L113+12
 2250 014c 4FF4FA62 	 mov r2,#2000
 2251 0150 DA80     	 strh r2,[r3,#6]
 2252              	.L103:
 531:../main.c     **** 				button2Pressed = 0;
 2253              	 .loc 2 531 0 is_stmt 1
 2254 0152 5A4B     	 ldr r3,.L113+20
 2255 0154 0022     	 movs r2,#0
 2256 0156 1A70     	 strb r2,[r3]
 2257              	.L102:
 532:../main.c     **** 			}
 533:../main.c     **** 			LCDCursorXY(0, 0);
 2258              	 .loc 2 533 0
 2259 0158 0020     	 movs r0,#0
 2260 015a 0021     	 movs r1,#0
 2261 015c FFF7FEFF 	 bl LCDCursorXY
 534:../main.c     **** 			LCDWriteData((set_time.year/1000)+0x30);
 2262              	 .loc 2 534 0
 2263 0160 544B     	 ldr r3,.L113+12
 2264 0162 DB88     	 ldrh r3,[r3,#6]
 2265 0164 564A     	 ldr r2,.L113+24
 2266 0166 A2FB0323 	 umull r2,r3,r2,r3
 2267 016a 9B09     	 lsrs r3,r3,#6
 2268 016c 9BB2     	 uxth r3,r3
 2269 016e DBB2     	 uxtb r3,r3
 2270 0170 3033     	 adds r3,r3,#48
 2271 0172 DBB2     	 uxtb r3,r3
 2272 0174 1846     	 mov r0,r3
 2273 0176 FFF7FEFF 	 bl LCDWriteData
 535:../main.c     **** 			erhan = set_time.year % 1000;
 2274              	 .loc 2 535 0
 2275 017a 4E4B     	 ldr r3,.L113+12
 2276 017c DB88     	 ldrh r3,[r3,#6]
 2277 017e 504A     	 ldr r2,.L113+24
 2278 0180 A2FB0312 	 umull r1,r2,r2,r3
 2279 0184 9209     	 lsrs r2,r2,#6
 2280 0186 4FF47A71 	 mov r1,#1000
 2281 018a 01FB02F2 	 mul r2,r1,r2
 2282 018e 9B1A     	 subs r3,r3,r2
 2283 0190 FB85     	 strh r3,[r7,#46]
 536:../main.c     **** 			LCDWriteData((erhan/100) + 0x30);
 2284              	 .loc 2 536 0
 2285 0192 FB8D     	 ldrh r3,[r7,#46]
 2286 0194 4B4A     	 ldr r2,.L113+28
 2287 0196 A2FB0323 	 umull r2,r3,r2,r3
 2288 019a 5B09     	 lsrs r3,r3,#5
 2289 019c 9BB2     	 uxth r3,r3
 2290 019e DBB2     	 uxtb r3,r3
 2291 01a0 3033     	 adds r3,r3,#48
 2292 01a2 DBB2     	 uxtb r3,r3
 2293 01a4 1846     	 mov r0,r3
 2294 01a6 FFF7FEFF 	 bl LCDWriteData
 537:../main.c     **** 			erhan = set_time.year % 100;
 2295              	 .loc 2 537 0
 2296 01aa 424B     	 ldr r3,.L113+12
 2297 01ac DB88     	 ldrh r3,[r3,#6]
 2298 01ae 454A     	 ldr r2,.L113+28
 2299 01b0 A2FB0312 	 umull r1,r2,r2,r3
 2300 01b4 5209     	 lsrs r2,r2,#5
 2301 01b6 6421     	 movs r1,#100
 2302 01b8 01FB02F2 	 mul r2,r1,r2
 2303 01bc 9B1A     	 subs r3,r3,r2
 2304 01be FB85     	 strh r3,[r7,#46]
 538:../main.c     **** 			LCDWriteData((erhan/10)+0x30);
 2305              	 .loc 2 538 0
 2306 01c0 FB8D     	 ldrh r3,[r7,#46]
 2307 01c2 414A     	 ldr r2,.L113+32
 2308 01c4 A2FB0323 	 umull r2,r3,r2,r3
 2309 01c8 DB08     	 lsrs r3,r3,#3
 2310 01ca 9BB2     	 uxth r3,r3
 2311 01cc DBB2     	 uxtb r3,r3
 2312 01ce 3033     	 adds r3,r3,#48
 2313 01d0 DBB2     	 uxtb r3,r3
 2314 01d2 1846     	 mov r0,r3
 2315 01d4 FFF7FEFF 	 bl LCDWriteData
 539:../main.c     **** 			LCDWriteData((erhan%10)+0x30);
 2316              	 .loc 2 539 0
 2317 01d8 FA8D     	 ldrh r2,[r7,#46]
 2318 01da 3B4B     	 ldr r3,.L113+32
 2319 01dc A3FB0213 	 umull r1,r3,r3,r2
 2320 01e0 D908     	 lsrs r1,r3,#3
 2321 01e2 0B46     	 mov r3,r1
 2322 01e4 9B00     	 lsls r3,r3,#2
 2323 01e6 0B44     	 add r3,r3,r1
 2324 01e8 5B00     	 lsls r3,r3,#1
 2325 01ea D31A     	 subs r3,r2,r3
 2326 01ec 9BB2     	 uxth r3,r3
 2327 01ee DBB2     	 uxtb r3,r3
 2328 01f0 3033     	 adds r3,r3,#48
 2329 01f2 DBB2     	 uxtb r3,r3
 2330 01f4 1846     	 mov r0,r3
 2331 01f6 FFF7FEFF 	 bl LCDWriteData
 540:../main.c     **** 			LCDWriteCommand(0x10);
 2332              	 .loc 2 540 0
 2333 01fa 1020     	 movs r0,#16
 2334 01fc FFF7FEFF 	 bl LCDWriteCommand
 541:../main.c     **** 		break;
 2335              	 .loc 2 541 0
 2336 0200 D8E1     	 b .L91
 2337              	.L97:
 542:../main.c     **** 
 543:../main.c     **** 		case MONTH:
 544:../main.c     **** 			if(button2Pressed)
 2338              	 .loc 2 544 0
 2339 0202 2E4B     	 ldr r3,.L113+20
 2340 0204 1B78     	 ldrb r3,[r3]
 2341 0206 002B     	 cmp r3,#0
 2342 0208 1DD0     	 beq .L104
 545:../main.c     **** 			{
 546:../main.c     **** 				if(++set_time.month>=13)
 2343              	 .loc 2 546 0
 2344 020a 2A4B     	 ldr r3,.L113+12
 2345 020c 5B79     	 ldrb r3,[r3,#5]
 2346 020e C3F30303 	 ubfx r3,r3,#0,#4
 2347 0212 DBB2     	 uxtb r3,r3
 2348 0214 0133     	 adds r3,r3,#1
 2349 0216 03F00F03 	 and r3,r3,#15
 2350 021a D9B2     	 uxtb r1,r3
 2351 021c 254A     	 ldr r2,.L113+12
 2352 021e 5379     	 ldrb r3,[r2,#5]
 2353 0220 61F30303 	 bfi r3,r1,#0,#4
 2354 0224 5371     	 strb r3,[r2,#5]
 2355 0226 234B     	 ldr r3,.L113+12
 2356 0228 5B79     	 ldrb r3,[r3,#5]
 2357 022a C3F30303 	 ubfx r3,r3,#0,#4
 2358 022e DBB2     	 uxtb r3,r3
 2359 0230 0C2B     	 cmp r3,#12
 2360 0232 05DD     	 ble .L105
 547:../main.c     **** 					set_time.month = 1;
 2361              	 .loc 2 547 0
 2362 0234 1F4A     	 ldr r2,.L113+12
 2363 0236 5379     	 ldrb r3,[r2,#5]
 2364 0238 0121     	 movs r1,#1
 2365 023a 61F30303 	 bfi r3,r1,#0,#4
 2366 023e 5371     	 strb r3,[r2,#5]
 2367              	.L105:
 548:../main.c     **** 				button2Pressed = 0;
 2368              	 .loc 2 548 0
 2369 0240 1E4B     	 ldr r3,.L113+20
 2370 0242 0022     	 movs r2,#0
 2371 0244 1A70     	 strb r2,[r3]
 2372              	.L104:
 549:../main.c     **** 			}
 550:../main.c     **** 			LCDCursorXY(0, 5);
 2373              	 .loc 2 550 0
 2374 0246 0020     	 movs r0,#0
 2375 0248 0521     	 movs r1,#5
 2376 024a FFF7FEFF 	 bl LCDCursorXY
 551:../main.c     **** 			LCDWriteData((set_time.month/10) + 0x30);
 2377              	 .loc 2 551 0
 2378 024e 194B     	 ldr r3,.L113+12
 2379 0250 5B79     	 ldrb r3,[r3,#5]
 2380 0252 C3F30303 	 ubfx r3,r3,#0,#4
 2381 0256 DBB2     	 uxtb r3,r3
 2382 0258 1C4A     	 ldr r2,.L113+36
 2383 025a 82FB0312 	 smull r1,r2,r2,r3
 2384 025e 9210     	 asrs r2,r2,#2
 2385 0260 DB17     	 asrs r3,r3,#31
 2386 0262 D31A     	 subs r3,r2,r3
 2387 0264 DBB2     	 uxtb r3,r3
 2388 0266 3033     	 adds r3,r3,#48
 2389 0268 DBB2     	 uxtb r3,r3
 2390 026a 1846     	 mov r0,r3
 2391 026c FFF7FEFF 	 bl LCDWriteData
 552:../main.c     **** 			LCDWriteData((set_time.month%10) + 0x30);
 2392              	 .loc 2 552 0
 2393 0270 104B     	 ldr r3,.L113+12
 2394 0272 5B79     	 ldrb r3,[r3,#5]
 2395 0274 C3F30303 	 ubfx r3,r3,#0,#4
 2396 0278 DBB2     	 uxtb r3,r3
 2397 027a 1946     	 mov r1,r3
 2398 027c 134B     	 ldr r3,.L113+36
 2399 027e 83FB0123 	 smull r2,r3,r3,r1
 2400 0282 9A10     	 asrs r2,r3,#2
 2401 0284 CB17     	 asrs r3,r1,#31
 2402 0286 D21A     	 subs r2,r2,r3
 2403 0288 1346     	 mov r3,r2
 2404 028a 9B00     	 lsls r3,r3,#2
 2405 028c 1344     	 add r3,r3,r2
 2406 028e 5B00     	 lsls r3,r3,#1
 2407 0290 CA1A     	 subs r2,r1,r3
 2408 0292 D3B2     	 uxtb r3,r2
 2409 0294 3033     	 adds r3,r3,#48
 2410 0296 DBB2     	 uxtb r3,r3
 2411 0298 1846     	 mov r0,r3
 2412 029a FFF7FEFF 	 bl LCDWriteData
 553:../main.c     **** 			LCDWriteCommand(0x10);
 2413              	 .loc 2 553 0
 2414 029e 1020     	 movs r0,#16
 2415 02a0 FFF7FEFF 	 bl LCDWriteCommand
 554:../main.c     **** 		break;
 2416              	 .loc 2 554 0
 2417 02a4 86E1     	 b .L91
 2418              	.L114:
 2419 02a6 00BF     	 .align 2
 2420              	.L113:
 2421 02a8 E8000000 	 .word .LC0
 2422 02ac 00000000 	 .word setTimeMenu
 2423 02b0 00000000 	 .word current_time
 2424 02b4 00000000 	 .word set_time
 2425 02b8 C8000000 	 .word .LC13
 2426 02bc 00000000 	 .word button2Pressed
 2427 02c0 D34D6210 	 .word 274877907
 2428 02c4 1F85EB51 	 .word 1374389535
 2429 02c8 CDCCCCCC 	 .word -858993459
 2430 02cc 67666666 	 .word 1717986919
 2431              	.L98:
 555:../main.c     **** 
 556:../main.c     **** 		case DAY:
 557:../main.c     **** 			if(button2Pressed)
 2432              	 .loc 2 557 0
 2433 02d0 BA4B     	 ldr r3,.L115
 2434 02d2 1B78     	 ldrb r3,[r3]
 2435 02d4 002B     	 cmp r3,#0
 2436 02d6 56D0     	 beq .L106
 558:../main.c     **** 			{
 559:../main.c     **** 				if(isLeapYear(set_time.year) && set_time.month==2)
 2437              	 .loc 2 559 0
 2438 02d8 B94B     	 ldr r3,.L115+4
 2439 02da DB88     	 ldrh r3,[r3,#6]
 2440 02dc 1846     	 mov r0,r3
 2441 02de FFF7FEFF 	 bl isLeapYear
 2442 02e2 0346     	 mov r3,r0
 2443 02e4 002B     	 cmp r3,#0
 2444 02e6 23D0     	 beq .L107
 2445              	 .loc 2 559 0 is_stmt 0 discriminator 1
 2446 02e8 B54B     	 ldr r3,.L115+4
 2447 02ea 5B79     	 ldrb r3,[r3,#5]
 2448 02ec 03F00F03 	 and r3,r3,#15
 2449 02f0 DBB2     	 uxtb r3,r3
 2450 02f2 022B     	 cmp r3,#2
 2451 02f4 1CD1     	 bne .L107
 560:../main.c     **** 				{
 561:../main.c     **** 					if(++set_time.days >= 30)	//Feb is max 29 days
 2452              	 .loc 2 561 0 is_stmt 1
 2453 02f6 B24B     	 ldr r3,.L115+4
 2454 02f8 DB78     	 ldrb r3,[r3,#3]
 2455 02fa C3F30403 	 ubfx r3,r3,#0,#5
 2456 02fe DBB2     	 uxtb r3,r3
 2457 0300 0133     	 adds r3,r3,#1
 2458 0302 03F01F03 	 and r3,r3,#31
 2459 0306 D9B2     	 uxtb r1,r3
 2460 0308 AD4A     	 ldr r2,.L115+4
 2461 030a D378     	 ldrb r3,[r2,#3]
 2462 030c 61F30403 	 bfi r3,r1,#0,#5
 2463 0310 D370     	 strb r3,[r2,#3]
 2464 0312 AB4B     	 ldr r3,.L115+4
 2465 0314 DB78     	 ldrb r3,[r3,#3]
 2466 0316 C3F30403 	 ubfx r3,r3,#0,#5
 2467 031a DBB2     	 uxtb r3,r3
 2468 031c 1D2B     	 cmp r3,#29
 2469 031e 06DD     	 ble .L108
 562:../main.c     **** 						set_time.days = 1;
 2470              	 .loc 2 562 0
 2471 0320 A74A     	 ldr r2,.L115+4
 2472 0322 D378     	 ldrb r3,[r2,#3]
 2473 0324 0121     	 movs r1,#1
 2474 0326 61F30403 	 bfi r3,r1,#0,#5
 2475 032a D370     	 strb r3,[r2,#3]
 561:../main.c     **** 						set_time.days = 1;
 2476              	 .loc 2 561 0
 2477 032c 28E0     	 b .L109
 2478              	.L108:
 2479 032e 27E0     	 b .L109
 2480              	.L107:
 563:../main.c     **** 				}
 564:../main.c     **** 				else
 565:../main.c     **** 				{
 566:../main.c     **** 					if(set_time.days >= monthsSize[set_time.month-1])
 2481              	 .loc 2 566 0
 2482 0330 A34B     	 ldr r3,.L115+4
 2483 0332 DB78     	 ldrb r3,[r3,#3]
 2484 0334 C3F30403 	 ubfx r3,r3,#0,#5
 2485 0338 DBB2     	 uxtb r3,r3
 2486 033a 1A46     	 mov r2,r3
 2487 033c A04B     	 ldr r3,.L115+4
 2488 033e 5B79     	 ldrb r3,[r3,#5]
 2489 0340 C3F30303 	 ubfx r3,r3,#0,#4
 2490 0344 DBB2     	 uxtb r3,r3
 2491 0346 013B     	 subs r3,r3,#1
 2492 0348 07F13001 	 add r1,r7,#48
 2493 034c 0B44     	 add r3,r3,r1
 2494 034e 13F8103C 	 ldrb r3,[r3,#-16]
 2495 0352 9A42     	 cmp r2,r3
 2496 0354 06DB     	 blt .L110
 567:../main.c     **** 						set_time.days = 1;
 2497              	 .loc 2 567 0
 2498 0356 9A4A     	 ldr r2,.L115+4
 2499 0358 D378     	 ldrb r3,[r2,#3]
 2500 035a 0121     	 movs r1,#1
 2501 035c 61F30403 	 bfi r3,r1,#0,#5
 2502 0360 D370     	 strb r3,[r2,#3]
 2503 0362 0DE0     	 b .L109
 2504              	.L110:
 568:../main.c     **** 					else
 569:../main.c     **** 						set_time.days++;
 2505              	 .loc 2 569 0
 2506 0364 964B     	 ldr r3,.L115+4
 2507 0366 DB78     	 ldrb r3,[r3,#3]
 2508 0368 C3F30403 	 ubfx r3,r3,#0,#5
 2509 036c DBB2     	 uxtb r3,r3
 2510 036e 0133     	 adds r3,r3,#1
 2511 0370 03F01F03 	 and r3,r3,#31
 2512 0374 D9B2     	 uxtb r1,r3
 2513 0376 924A     	 ldr r2,.L115+4
 2514 0378 D378     	 ldrb r3,[r2,#3]
 2515 037a 61F30403 	 bfi r3,r1,#0,#5
 2516 037e D370     	 strb r3,[r2,#3]
 2517              	.L109:
 570:../main.c     **** 				}
 571:../main.c     **** 				button2Pressed = 0;
 2518              	 .loc 2 571 0
 2519 0380 8E4B     	 ldr r3,.L115
 2520 0382 0022     	 movs r2,#0
 2521 0384 1A70     	 strb r2,[r3]
 2522              	.L106:
 572:../main.c     **** 			}
 573:../main.c     **** 			LCDCursorXY(0, 8);
 2523              	 .loc 2 573 0
 2524 0386 0020     	 movs r0,#0
 2525 0388 0821     	 movs r1,#8
 2526 038a FFF7FEFF 	 bl LCDCursorXY
 574:../main.c     **** 			LCDWriteData((set_time.days/10) + 0x30);
 2527              	 .loc 2 574 0
 2528 038e 8C4B     	 ldr r3,.L115+4
 2529 0390 DB78     	 ldrb r3,[r3,#3]
 2530 0392 C3F30403 	 ubfx r3,r3,#0,#5
 2531 0396 DBB2     	 uxtb r3,r3
 2532 0398 8A4A     	 ldr r2,.L115+8
 2533 039a 82FB0312 	 smull r1,r2,r2,r3
 2534 039e 9210     	 asrs r2,r2,#2
 2535 03a0 DB17     	 asrs r3,r3,#31
 2536 03a2 D31A     	 subs r3,r2,r3
 2537 03a4 DBB2     	 uxtb r3,r3
 2538 03a6 3033     	 adds r3,r3,#48
 2539 03a8 DBB2     	 uxtb r3,r3
 2540 03aa 1846     	 mov r0,r3
 2541 03ac FFF7FEFF 	 bl LCDWriteData
 575:../main.c     **** 			LCDWriteData((set_time.days%10) + 0x30);
 2542              	 .loc 2 575 0
 2543 03b0 834B     	 ldr r3,.L115+4
 2544 03b2 DB78     	 ldrb r3,[r3,#3]
 2545 03b4 C3F30403 	 ubfx r3,r3,#0,#5
 2546 03b8 DBB2     	 uxtb r3,r3
 2547 03ba 1946     	 mov r1,r3
 2548 03bc 814B     	 ldr r3,.L115+8
 2549 03be 83FB0123 	 smull r2,r3,r3,r1
 2550 03c2 9A10     	 asrs r2,r3,#2
 2551 03c4 CB17     	 asrs r3,r1,#31
 2552 03c6 D21A     	 subs r2,r2,r3
 2553 03c8 1346     	 mov r3,r2
 2554 03ca 9B00     	 lsls r3,r3,#2
 2555 03cc 1344     	 add r3,r3,r2
 2556 03ce 5B00     	 lsls r3,r3,#1
 2557 03d0 CA1A     	 subs r2,r1,r3
 2558 03d2 D3B2     	 uxtb r3,r2
 2559 03d4 3033     	 adds r3,r3,#48
 2560 03d6 DBB2     	 uxtb r3,r3
 2561 03d8 1846     	 mov r0,r3
 2562 03da FFF7FEFF 	 bl LCDWriteData
 576:../main.c     **** 			LCDWriteCommand(0x10);
 2563              	 .loc 2 576 0
 2564 03de 1020     	 movs r0,#16
 2565 03e0 FFF7FEFF 	 bl LCDWriteCommand
 577:../main.c     **** 		break;
 2566              	 .loc 2 577 0
 2567 03e4 E6E0     	 b .L91
 2568              	.L99:
 578:../main.c     **** 
 579:../main.c     **** 		case HOUR:
 580:../main.c     **** 			if(button2Pressed)
 2569              	 .loc 2 580 0
 2570 03e6 754B     	 ldr r3,.L115
 2571 03e8 1B78     	 ldrb r3,[r3]
 2572 03ea 002B     	 cmp r3,#0
 2573 03ec 2AD0     	 beq .L111
 581:../main.c     **** 			{
 582:../main.c     **** 				set_time.hours++;
 2574              	 .loc 2 582 0
 2575 03ee 744B     	 ldr r3,.L115+4
 2576 03f0 9B78     	 ldrb r3,[r3,#2]
 2577 03f2 C3F30403 	 ubfx r3,r3,#0,#5
 2578 03f6 DBB2     	 uxtb r3,r3
 2579 03f8 0133     	 adds r3,r3,#1
 2580 03fa 03F01F03 	 and r3,r3,#31
 2581 03fe D9B2     	 uxtb r1,r3
 2582 0400 6F4A     	 ldr r2,.L115+4
 2583 0402 9378     	 ldrb r3,[r2,#2]
 2584 0404 61F30403 	 bfi r3,r1,#0,#5
 2585 0408 9370     	 strb r3,[r2,#2]
 583:../main.c     **** 				set_time.hours = set_time.hours % 24;
 2586              	 .loc 2 583 0
 2587 040a 6D4B     	 ldr r3,.L115+4
 2588 040c 9B78     	 ldrb r3,[r3,#2]
 2589 040e C3F30403 	 ubfx r3,r3,#0,#5
 2590 0412 DBB2     	 uxtb r3,r3
 2591 0414 1946     	 mov r1,r3
 2592 0416 6C4B     	 ldr r3,.L115+12
 2593 0418 83FB0123 	 smull r2,r3,r3,r1
 2594 041c 9A10     	 asrs r2,r3,#2
 2595 041e CB17     	 asrs r3,r1,#31
 2596 0420 D21A     	 subs r2,r2,r3
 2597 0422 1346     	 mov r3,r2
 2598 0424 5B00     	 lsls r3,r3,#1
 2599 0426 1344     	 add r3,r3,r2
 2600 0428 DB00     	 lsls r3,r3,#3
 2601 042a CA1A     	 subs r2,r1,r3
 2602 042c D3B2     	 uxtb r3,r2
 2603 042e 03F01F03 	 and r3,r3,#31
 2604 0432 D9B2     	 uxtb r1,r3
 2605 0434 624A     	 ldr r2,.L115+4
 2606 0436 9378     	 ldrb r3,[r2,#2]
 2607 0438 61F30403 	 bfi r3,r1,#0,#5
 2608 043c 9370     	 strb r3,[r2,#2]
 584:../main.c     **** 				button2Pressed = 0;
 2609              	 .loc 2 584 0
 2610 043e 5F4B     	 ldr r3,.L115
 2611 0440 0022     	 movs r2,#0
 2612 0442 1A70     	 strb r2,[r3]
 2613              	.L111:
 585:../main.c     **** 			}
 586:../main.c     **** 			LCDCursorXY(0, 11);
 2614              	 .loc 2 586 0
 2615 0444 0020     	 movs r0,#0
 2616 0446 0B21     	 movs r1,#11
 2617 0448 FFF7FEFF 	 bl LCDCursorXY
 587:../main.c     **** 			LCDWriteData((set_time.hours/10) + 0x30);
 2618              	 .loc 2 587 0
 2619 044c 5C4B     	 ldr r3,.L115+4
 2620 044e 9B78     	 ldrb r3,[r3,#2]
 2621 0450 C3F30403 	 ubfx r3,r3,#0,#5
 2622 0454 DBB2     	 uxtb r3,r3
 2623 0456 5B4A     	 ldr r2,.L115+8
 2624 0458 82FB0312 	 smull r1,r2,r2,r3
 2625 045c 9210     	 asrs r2,r2,#2
 2626 045e DB17     	 asrs r3,r3,#31
 2627 0460 D31A     	 subs r3,r2,r3
 2628 0462 DBB2     	 uxtb r3,r3
 2629 0464 3033     	 adds r3,r3,#48
 2630 0466 DBB2     	 uxtb r3,r3
 2631 0468 1846     	 mov r0,r3
 2632 046a FFF7FEFF 	 bl LCDWriteData
 588:../main.c     **** 			LCDWriteData((set_time.hours%10) + 0x30);
 2633              	 .loc 2 588 0
 2634 046e 544B     	 ldr r3,.L115+4
 2635 0470 9B78     	 ldrb r3,[r3,#2]
 2636 0472 C3F30403 	 ubfx r3,r3,#0,#5
 2637 0476 DBB2     	 uxtb r3,r3
 2638 0478 1946     	 mov r1,r3
 2639 047a 524B     	 ldr r3,.L115+8
 2640 047c 83FB0123 	 smull r2,r3,r3,r1
 2641 0480 9A10     	 asrs r2,r3,#2
 2642 0482 CB17     	 asrs r3,r1,#31
 2643 0484 D21A     	 subs r2,r2,r3
 2644 0486 1346     	 mov r3,r2
 2645 0488 9B00     	 lsls r3,r3,#2
 2646 048a 1344     	 add r3,r3,r2
 2647 048c 5B00     	 lsls r3,r3,#1
 2648 048e CA1A     	 subs r2,r1,r3
 2649 0490 D3B2     	 uxtb r3,r2
 2650 0492 3033     	 adds r3,r3,#48
 2651 0494 DBB2     	 uxtb r3,r3
 2652 0496 1846     	 mov r0,r3
 2653 0498 FFF7FEFF 	 bl LCDWriteData
 589:../main.c     **** 			LCDWriteCommand(0x10);
 2654              	 .loc 2 589 0
 2655 049c 1020     	 movs r0,#16
 2656 049e FFF7FEFF 	 bl LCDWriteCommand
 590:../main.c     **** 		break;
 2657              	 .loc 2 590 0
 2658 04a2 87E0     	 b .L91
 2659              	.L100:
 591:../main.c     **** 
 592:../main.c     **** 		case MINUTE:
 593:../main.c     **** 			if(button2Pressed)
 2660              	 .loc 2 593 0
 2661 04a4 454B     	 ldr r3,.L115
 2662 04a6 1B78     	 ldrb r3,[r3]
 2663 04a8 002B     	 cmp r3,#0
 2664 04aa 2BD0     	 beq .L112
 594:../main.c     **** 			{
 595:../main.c     **** 				set_time.minutes++;
 2665              	 .loc 2 595 0
 2666 04ac 444B     	 ldr r3,.L115+4
 2667 04ae 5B78     	 ldrb r3,[r3,#1]
 2668 04b0 C3F30503 	 ubfx r3,r3,#0,#6
 2669 04b4 DBB2     	 uxtb r3,r3
 2670 04b6 0133     	 adds r3,r3,#1
 2671 04b8 03F03F03 	 and r3,r3,#63
 2672 04bc D9B2     	 uxtb r1,r3
 2673 04be 404A     	 ldr r2,.L115+4
 2674 04c0 5378     	 ldrb r3,[r2,#1]
 2675 04c2 61F30503 	 bfi r3,r1,#0,#6
 2676 04c6 5370     	 strb r3,[r2,#1]
 596:../main.c     **** 				set_time.minutes = set_time.minutes % 60;
 2677              	 .loc 2 596 0
 2678 04c8 3D4B     	 ldr r3,.L115+4
 2679 04ca 5B78     	 ldrb r3,[r3,#1]
 2680 04cc C3F30503 	 ubfx r3,r3,#0,#6
 2681 04d0 DBB2     	 uxtb r3,r3
 2682 04d2 1A46     	 mov r2,r3
 2683 04d4 3D4B     	 ldr r3,.L115+16
 2684 04d6 82FB0301 	 smull r0,r1,r2,r3
 2685 04da 5318     	 adds r3,r2,r1
 2686 04dc 5911     	 asrs r1,r3,#5
 2687 04de D317     	 asrs r3,r2,#31
 2688 04e0 C91A     	 subs r1,r1,r3
 2689 04e2 0B46     	 mov r3,r1
 2690 04e4 1B01     	 lsls r3,r3,#4
 2691 04e6 5B1A     	 subs r3,r3,r1
 2692 04e8 9B00     	 lsls r3,r3,#2
 2693 04ea D11A     	 subs r1,r2,r3
 2694 04ec CBB2     	 uxtb r3,r1
 2695 04ee 03F03F03 	 and r3,r3,#63
 2696 04f2 D9B2     	 uxtb r1,r3
 2697 04f4 324A     	 ldr r2,.L115+4
 2698 04f6 5378     	 ldrb r3,[r2,#1]
 2699 04f8 61F30503 	 bfi r3,r1,#0,#6
 2700 04fc 5370     	 strb r3,[r2,#1]
 597:../main.c     **** 				button2Pressed = 0;
 2701              	 .loc 2 597 0
 2702 04fe 2F4B     	 ldr r3,.L115
 2703 0500 0022     	 movs r2,#0
 2704 0502 1A70     	 strb r2,[r3]
 2705              	.L112:
 598:../main.c     **** 			}
 599:../main.c     **** 			LCDCursorXY(0, 14);
 2706              	 .loc 2 599 0
 2707 0504 0020     	 movs r0,#0
 2708 0506 0E21     	 movs r1,#14
 2709 0508 FFF7FEFF 	 bl LCDCursorXY
 600:../main.c     **** 			LCDWriteData((set_time.minutes/10) + 0x30);
 2710              	 .loc 2 600 0
 2711 050c 2C4B     	 ldr r3,.L115+4
 2712 050e 5B78     	 ldrb r3,[r3,#1]
 2713 0510 C3F30503 	 ubfx r3,r3,#0,#6
 2714 0514 DBB2     	 uxtb r3,r3
 2715 0516 2B4A     	 ldr r2,.L115+8
 2716 0518 82FB0312 	 smull r1,r2,r2,r3
 2717 051c 9210     	 asrs r2,r2,#2
 2718 051e DB17     	 asrs r3,r3,#31
 2719 0520 D31A     	 subs r3,r2,r3
 2720 0522 DBB2     	 uxtb r3,r3
 2721 0524 3033     	 adds r3,r3,#48
 2722 0526 DBB2     	 uxtb r3,r3
 2723 0528 1846     	 mov r0,r3
 2724 052a FFF7FEFF 	 bl LCDWriteData
 601:../main.c     **** 			LCDWriteData((set_time.minutes%10) + 0x30);
 2725              	 .loc 2 601 0
 2726 052e 244B     	 ldr r3,.L115+4
 2727 0530 5B78     	 ldrb r3,[r3,#1]
 2728 0532 C3F30503 	 ubfx r3,r3,#0,#6
 2729 0536 DBB2     	 uxtb r3,r3
 2730 0538 1946     	 mov r1,r3
 2731 053a 224B     	 ldr r3,.L115+8
 2732 053c 83FB0123 	 smull r2,r3,r3,r1
 2733 0540 9A10     	 asrs r2,r3,#2
 2734 0542 CB17     	 asrs r3,r1,#31
 2735 0544 D21A     	 subs r2,r2,r3
 2736 0546 1346     	 mov r3,r2
 2737 0548 9B00     	 lsls r3,r3,#2
 2738 054a 1344     	 add r3,r3,r2
 2739 054c 5B00     	 lsls r3,r3,#1
 2740 054e CA1A     	 subs r2,r1,r3
 2741 0550 D3B2     	 uxtb r3,r2
 2742 0552 3033     	 adds r3,r3,#48
 2743 0554 DBB2     	 uxtb r3,r3
 2744 0556 1846     	 mov r0,r3
 2745 0558 FFF7FEFF 	 bl LCDWriteData
 602:../main.c     **** 			LCDWriteCommand(0x10);
 2746              	 .loc 2 602 0
 2747 055c 1020     	 movs r0,#16
 2748 055e FFF7FEFF 	 bl LCDWriteCommand
 603:../main.c     **** 		break;
 2749              	 .loc 2 603 0
 2750 0562 27E0     	 b .L91
 2751              	.L101:
 604:../main.c     **** 
 605:../main.c     **** 		case SET_OK:
 606:../main.c     **** 		set_time.month--;
 2752              	 .loc 2 606 0
 2753 0564 164B     	 ldr r3,.L115+4
 2754 0566 5B79     	 ldrb r3,[r3,#5]
 2755 0568 C3F30303 	 ubfx r3,r3,#0,#4
 2756 056c DBB2     	 uxtb r3,r3
 2757 056e 0F33     	 adds r3,r3,#15
 2758 0570 03F00F03 	 and r3,r3,#15
 2759 0574 D9B2     	 uxtb r1,r3
 2760 0576 124A     	 ldr r2,.L115+4
 2761 0578 5379     	 ldrb r3,[r2,#5]
 2762 057a 61F30303 	 bfi r3,r1,#0,#4
 2763 057e 5371     	 strb r3,[r2,#5]
 607:../main.c     **** 		set_time.days--;
 2764              	 .loc 2 607 0
 2765 0580 0F4B     	 ldr r3,.L115+4
 2766 0582 DB78     	 ldrb r3,[r3,#3]
 2767 0584 C3F30403 	 ubfx r3,r3,#0,#5
 2768 0588 DBB2     	 uxtb r3,r3
 2769 058a 1F33     	 adds r3,r3,#31
 2770 058c 03F01F03 	 and r3,r3,#31
 2771 0590 D9B2     	 uxtb r1,r3
 2772 0592 0B4A     	 ldr r2,.L115+4
 2773 0594 D378     	 ldrb r3,[r2,#3]
 2774 0596 61F30403 	 bfi r3,r1,#0,#5
 2775 059a D370     	 strb r3,[r2,#3]
 608:../main.c     **** 		XMC_RTC_SetTime(&set_time);
 2776              	 .loc 2 608 0
 2777 059c 0848     	 ldr r0,.L115+4
 2778 059e FFF7FEFF 	 bl XMC_RTC_SetTime
 609:../main.c     **** 		UpdateLCD();
 2779              	 .loc 2 609 0
 2780 05a2 FFF7FEFF 	 bl UpdateLCD
 610:../main.c     **** 		//XMC_RTC_GetTime(&current_time);
 611:../main.c     **** 		//LCDCursorXY(1, 0);
 612:../main.c     **** 		//sprintf(temp, "%04d/%02d/%02d %02d:%02d:%02d",current_time.year,current_time.month,current_time
 613:../main.c     **** 		//LCDWriteString(temp);
 614:../main.c     **** 		setTimeMenu=0;
 2781              	 .loc 2 614 0
 2782 05a6 0A4B     	 ldr r3,.L115+20
 2783 05a8 0022     	 movs r2,#0
 2784 05aa 1A70     	 strb r2,[r3]
 615:../main.c     **** 		setTimeOnProcces = 0;
 2785              	 .loc 2 615 0
 2786 05ac 094B     	 ldr r3,.L115+24
 2787 05ae 0022     	 movs r2,#0
 2788 05b0 1A70     	 strb r2,[r3]
 616:../main.c     **** 		break;
 2789              	 .loc 2 616 0
 2790 05b2 00BF     	 nop
 2791              	.L91:
 617:../main.c     **** 	}
 618:../main.c     **** }
 2792              	 .loc 2 618 0
 2793 05b4 3437     	 adds r7,r7,#52
 2794              	.LCFI53:
 2795              	 .cfi_def_cfa_offset 20
 2796 05b6 BD46     	 mov sp,r7
 2797              	.LCFI54:
 2798              	 .cfi_def_cfa_register 13
 2799              	 
 2800 05b8 F0BD     	 pop {r4,r5,r6,r7,pc}
 2801              	.L116:
 2802 05ba 00BF     	 .align 2
 2803              	.L115:
 2804 05bc 00000000 	 .word button2Pressed
 2805 05c0 00000000 	 .word set_time
 2806 05c4 67666666 	 .word 1717986919
 2807 05c8 ABAAAA2A 	 .word 715827883
 2808 05cc 89888888 	 .word -2004318071
 2809 05d0 00000000 	 .word setTimeMenu
 2810 05d4 00000000 	 .word setTimeOnProcces
 2811              	 .cfi_endproc
 2812              	.LFE440:
 2814              	 .section .rodata
 2815              	 .align 2
 2816              	.LC14:
 2817 00f4 496E6974 	 .ascii "Initializing...\000"
 2817      69616C69 
 2817      7A696E67 
 2817      2E2E2E00 
 2818              	 .align 2
 2819              	.LC15:
 2820 0104 496E6974 	 .ascii "Initialized...\000"
 2820      69616C69 
 2820      7A65642E 
 2820      2E2E00
 2821 0113 00       	 .align 2
 2822              	.LC16:
 2823 0114 65726861 	 .ascii "erhan.txt\000"
 2823      6E2E7478 
 2823      7400
 2824 011e 0000     	 .align 2
 2825              	.LC17:
 2826 0120 66697273 	 .ascii "first of all Special thanks to Erhan YILMAZ!!!\015\012"
 2826      74206F66 
 2826      20616C6C 
 2826      20537065 
 2826      6369616C 
 2827 0150 00       	 .ascii "\000"
 2828 0151 000000   	 .section .text.main,"ax",%progbits
 2829              	 .align 2
 2830              	 .global main
 2831              	 .thumb
 2832              	 .thumb_func
 2834              	main:
 2835              	.LFB441:
 619:../main.c     **** 
 620:../main.c     **** int main(void)
 621:../main.c     **** {
 2836              	 .loc 2 621 0
 2837              	 .cfi_startproc
 2838              	 
 2839              	 
 2840 0000 80B5     	 push {r7,lr}
 2841              	.LCFI55:
 2842              	 .cfi_def_cfa_offset 8
 2843              	 .cfi_offset 7,-8
 2844              	 .cfi_offset 14,-4
 2845 0002 84B0     	 sub sp,sp,#16
 2846              	.LCFI56:
 2847              	 .cfi_def_cfa_offset 24
 2848 0004 02AF     	 add r7,sp,#8
 2849              	.LCFI57:
 2850              	 .cfi_def_cfa 7,16
 622:../main.c     **** 	DAVE_STATUS_t status;
 623:../main.c     **** 	uint8_t erhan;
 624:../main.c     **** 	uint16_t erhan2;
 625:../main.c     **** 
 626:../main.c     **** 	status = DAVE_Init();           /* Initialization of DAVE APPs  */
 2851              	 .loc 2 626 0
 2852 0006 FFF7FEFF 	 bl DAVE_Init
 2853 000a 0346     	 mov r3,r0
 2854 000c FB70     	 strb r3,[r7,#3]
 627:../main.c     **** 	if(status != DAVE_STATUS_SUCCESS)
 2855              	 .loc 2 627 0
 2856 000e FB78     	 ldrb r3,[r7,#3]
 2857 0010 002B     	 cmp r3,#0
 2858 0012 00D0     	 beq .L118
 2859              	.L119:
 628:../main.c     **** 	{
 629:../main.c     **** 		/* Placeholder for error handler code. The while loop below can be replaced with an user error ha
 630:../main.c     **** 		XMC_DEBUG("DAVE APPs initialization failed\n");
 631:../main.c     **** 
 632:../main.c     **** 		while(1U)
 633:../main.c     **** 		{
 634:../main.c     **** 
 635:../main.c     **** 		}
 2860              	 .loc 2 635 0 discriminator 1
 2861 0014 FEE7     	 b .L119
 2862              	.L118:
 636:../main.c     **** 	}
 637:../main.c     **** 
 638:../main.c     **** 
 639:../main.c     **** 	// Set LED1, LED2 gpio pins.
 640:../main.c     **** 	XMC_GPIO_SetMode(LED1, XMC_GPIO_MODE_OUTPUT_PUSH_PULL);
 2863              	 .loc 2 640 0
 2864 0016 7F48     	 ldr r0,.L135
 2865 0018 0121     	 movs r1,#1
 2866 001a 8022     	 movs r2,#128
 2867 001c FFF7FEFF 	 bl XMC_GPIO_SetMode
 641:../main.c     **** 	XMC_GPIO_SetOutputLow(LED1);
 2868              	 .loc 2 641 0
 2869 0020 7C48     	 ldr r0,.L135
 2870 0022 0121     	 movs r1,#1
 2871 0024 FFF7FEFF 	 bl XMC_GPIO_SetOutputLow
 642:../main.c     **** 	XMC_GPIO_SetMode(LED2, XMC_GPIO_MODE_OUTPUT_PUSH_PULL);
 2872              	 .loc 2 642 0
 2873 0028 7A48     	 ldr r0,.L135
 2874 002a 0021     	 movs r1,#0
 2875 002c 8022     	 movs r2,#128
 2876 002e FFF7FEFF 	 bl XMC_GPIO_SetMode
 643:../main.c     **** 	XMC_GPIO_SetOutputLow(LED2);
 2877              	 .loc 2 643 0
 2878 0032 7848     	 ldr r0,.L135
 2879 0034 0021     	 movs r1,#0
 2880 0036 FFF7FEFF 	 bl XMC_GPIO_SetOutputLow
 644:../main.c     **** 	//XMC_GPIO_SetMode(BUTTON1,XMC_GPIO_MODE_INPUT_PULL_UP);
 645:../main.c     **** 	///////////////////////////////////////////////////////
 646:../main.c     **** 	LCDInit();
 2881              	 .loc 2 646 0
 2882 003a FFF7FEFF 	 bl LCDInit
 647:../main.c     **** 	LCDCursorXY(0, 0);
 2883              	 .loc 2 647 0
 2884 003e 0020     	 movs r0,#0
 2885 0040 0021     	 movs r1,#0
 2886 0042 FFF7FEFF 	 bl LCDCursorXY
 648:../main.c     **** 	LCDWriteString("Initializing...");
 2887              	 .loc 2 648 0
 2888 0046 7448     	 ldr r0,.L135+4
 2889 0048 FFF7FEFF 	 bl LCDWriteString
 649:../main.c     **** 	onProcess = 1;
 2890              	 .loc 2 649 0
 2891 004c 734B     	 ldr r3,.L135+8
 2892 004e 0122     	 movs r2,#1
 2893 0050 1A70     	 strb r2,[r3]
 650:../main.c     **** 	CAN_OBDII_LMO_01_Config.mo_ptr->can_identifier = 0x7e7;
 2894              	 .loc 2 650 0
 2895 0052 734B     	 ldr r3,.L135+12
 2896 0054 1A68     	 ldr r2,[r3]
 2897 0056 5368     	 ldr r3,[r2,#4]
 2898 0058 40F2E771 	 movw r1,#2023
 2899 005c 61F31C03 	 bfi r3,r1,#0,#29
 2900 0060 5360     	 str r3,[r2,#4]
 651:../main.c     **** 	CAN_OBDII_LMO_01_Config.mo_ptr->can_id_mask = 0x7FF;
 2901              	 .loc 2 651 0
 2902 0062 6F4B     	 ldr r3,.L135+12
 2903 0064 1A68     	 ldr r2,[r3]
 2904 0066 9368     	 ldr r3,[r2,#8]
 2905 0068 40F2FF71 	 movw r1,#2047
 2906 006c 61F31C03 	 bfi r3,r1,#0,#29
 2907 0070 9360     	 str r3,[r2,#8]
 652:../main.c     **** 	CAN_OBDII_LMO_01_Config.mo_ptr->can_data_length=8;
 2908              	 .loc 2 652 0
 2909 0072 6B4B     	 ldr r3,.L135+12
 2910 0074 1B68     	 ldr r3,[r3]
 2911 0076 0822     	 movs r2,#8
 2912 0078 1A73     	 strb r2,[r3,#12]
 653:../main.c     **** 	CAN_NODE_MO_Init(&CAN_OBDII_LMO_01_Config);
 2913              	 .loc 2 653 0
 2914 007a 6948     	 ldr r0,.L135+12
 2915 007c FFF7FEFF 	 bl CAN_NODE_MO_Init
 654:../main.c     **** 	for(erhan=0; erhan<10; erhan++)
 2916              	 .loc 2 654 0
 2917 0080 0023     	 movs r3,#0
 2918 0082 FB71     	 strb r3,[r7,#7]
 2919 0084 14E0     	 b .L120
 2920              	.L123:
 655:../main.c     **** 	{
 656:../main.c     **** 		CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,flowControl);
 2921              	 .loc 2 656 0
 2922 0086 6648     	 ldr r0,.L135+12
 2923 0088 6649     	 ldr r1,.L135+16
 2924 008a FFF7FEFF 	 bl CAN_NODE_MO_UpdateData
 657:../main.c     **** 		CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
 2925              	 .loc 2 657 0
 2926 008e 6448     	 ldr r0,.L135+12
 2927 0090 FFF7FEFF 	 bl CAN_NODE_MO_Transmit
 658:../main.c     **** 		for(erhan2=0; erhan2<65000; erhan2++);
 2928              	 .loc 2 658 0
 2929 0094 0023     	 movs r3,#0
 2930 0096 BB80     	 strh r3,[r7,#4]
 2931 0098 02E0     	 b .L121
 2932              	.L122:
 2933              	 .loc 2 658 0 is_stmt 0 discriminator 3
 2934 009a BB88     	 ldrh r3,[r7,#4]
 2935 009c 0133     	 adds r3,r3,#1
 2936 009e BB80     	 strh r3,[r7,#4]
 2937              	.L121:
 2938              	 .loc 2 658 0 discriminator 1
 2939 00a0 BB88     	 ldrh r3,[r7,#4]
 2940 00a2 4FF6E752 	 movw r2,#64999
 2941 00a6 9342     	 cmp r3,r2
 2942 00a8 F7D9     	 bls .L122
 654:../main.c     **** 	{
 2943              	 .loc 2 654 0 is_stmt 1 discriminator 2
 2944 00aa FB79     	 ldrb r3,[r7,#7]
 2945 00ac 0133     	 adds r3,r3,#1
 2946 00ae FB71     	 strb r3,[r7,#7]
 2947              	.L120:
 654:../main.c     **** 	{
 2948              	 .loc 2 654 0 is_stmt 0 discriminator 1
 2949 00b0 FB79     	 ldrb r3,[r7,#7]
 2950 00b2 092B     	 cmp r3,#9
 2951 00b4 E7D9     	 bls .L123
 659:../main.c     **** 	}
 660:../main.c     **** 	onProcess = 0;
 2952              	 .loc 2 660 0 is_stmt 1
 2953 00b6 594B     	 ldr r3,.L135+8
 2954 00b8 0022     	 movs r2,#0
 2955 00ba 1A70     	 strb r2,[r3]
 661:../main.c     **** 	LCDCursorXY(0, 0);
 2956              	 .loc 2 661 0
 2957 00bc 0020     	 movs r0,#0
 2958 00be 0021     	 movs r1,#0
 2959 00c0 FFF7FEFF 	 bl LCDCursorXY
 662:../main.c     **** 	LCDWriteString("Initialized...");
 2960              	 .loc 2 662 0
 2961 00c4 5848     	 ldr r0,.L135+20
 2962 00c6 FFF7FEFF 	 bl LCDWriteString
 663:../main.c     **** 	smartdata.velocitiy=0;
 2963              	 .loc 2 663 0
 2964 00ca 584B     	 ldr r3,.L135+24
 2965 00cc 0022     	 movs r2,#0
 2966 00ce 1A80     	 strh r2,[r3]
 664:../main.c     **** 	smartdata.battAmp=0;
 2967              	 .loc 2 664 0
 2968 00d0 564B     	 ldr r3,.L135+24
 2969 00d2 4FF00002 	 mov r2,#0
 2970 00d6 5A60     	 str r2,[r3,#4]
 665:../main.c     **** 	smartdata.battVolt = 0;
 2971              	 .loc 2 665 0
 2972 00d8 544B     	 ldr r3,.L135+24
 2973 00da 4FF00002 	 mov r2,#0
 2974 00de 9A60     	 str r2,[r3,#8]
 666:../main.c     **** 	smartdata.battEnergy=0;
 2975              	 .loc 2 666 0
 2976 00e0 524B     	 ldr r3,.L135+24
 2977 00e2 4FF00002 	 mov r2,#0
 2978 00e6 1A61     	 str r2,[r3,#16]
 667:../main.c     **** 	smartdata.battPower=0;
 2979              	 .loc 2 667 0
 2980 00e8 504B     	 ldr r3,.L135+24
 2981 00ea 4FF00002 	 mov r2,#0
 2982 00ee DA60     	 str r2,[r3,#12]
 668:../main.c     **** 	dataUpdated=0;
 2983              	 .loc 2 668 0
 2984 00f0 4F4B     	 ldr r3,.L135+28
 2985 00f2 0022     	 movs r2,#0
 2986 00f4 1A70     	 strb r2,[r3]
 669:../main.c     **** 	setTimeMenu = 0;
 2987              	 .loc 2 669 0
 2988 00f6 4F4B     	 ldr r3,.L135+32
 2989 00f8 0022     	 movs r2,#0
 2990 00fa 1A70     	 strb r2,[r3]
 670:../main.c     **** 	writeToEndOfFile(&FatFs, &Fil,"erhan.txt", "first of all Special thanks to Erhan YILMAZ!!!\r\n",si
 2991              	 .loc 2 670 0
 2992 00fc 3123     	 movs r3,#49
 2993 00fe 0093     	 str r3,[sp]
 2994 0100 4D48     	 ldr r0,.L135+36
 2995 0102 4E49     	 ldr r1,.L135+40
 2996 0104 4E4A     	 ldr r2,.L135+44
 2997 0106 4F4B     	 ldr r3,.L135+48
 2998 0108 FFF7FEFF 	 bl writeToEndOfFile
 671:../main.c     **** 
 672:../main.c     **** 	UpdateLCD();
 2999              	 .loc 2 672 0
 3000 010c FFF7FEFF 	 bl UpdateLCD
 3001              	.L134:
 673:../main.c     **** 	while(1U)
 674:../main.c     **** 	{
 675:../main.c     **** 		if(dataUpdated)
 3002              	 .loc 2 675 0
 3003 0110 474B     	 ldr r3,.L135+28
 3004 0112 1B78     	 ldrb r3,[r3]
 3005 0114 002B     	 cmp r3,#0
 3006 0116 28D0     	 beq .L124
 676:../main.c     **** 		{
 677:../main.c     **** 			smartdata.battPower = (smartdata.battVolt * smartdata.battAmp)/1000.0;
 3007              	 .loc 2 677 0
 3008 0118 444B     	 ldr r3,.L135+24
 3009 011a 93ED027A 	 flds s14,[r3,#8]
 3010 011e 434B     	 ldr r3,.L135+24
 3011 0120 D3ED017A 	 flds s15,[r3,#4]
 3012 0124 67EE277A 	 fmuls s15,s14,s15
 3013 0128 9FED477A 	 flds s14,.L135+52
 3014 012c C7EE877A 	 fdivs s15,s15,s14
 3015 0130 3E4B     	 ldr r3,.L135+24
 3016 0132 C3ED037A 	 fsts s15,[r3,#12]
 678:../main.c     **** 			smartdata.battEnergy = smartdata.battEnergy + (smartdata.battPower/3600.0f);
 3017              	 .loc 2 678 0
 3018 0136 3D4B     	 ldr r3,.L135+24
 3019 0138 93ED047A 	 flds s14,[r3,#16]
 3020 013c 3B4B     	 ldr r3,.L135+24
 3021 013e D3ED037A 	 flds s15,[r3,#12]
 3022 0142 DFED426A 	 flds s13,.L135+56
 3023 0146 C7EEA67A 	 fdivs s15,s15,s13
 3024 014a 77EE277A 	 fadds s15,s14,s15
 3025 014e 374B     	 ldr r3,.L135+24
 3026 0150 C3ED047A 	 fsts s15,[r3,#16]
 679:../main.c     **** 			UpdateSDCard();
 3027              	 .loc 2 679 0
 3028 0154 FFF7FEFF 	 bl UpdateSDCard
 680:../main.c     **** 			if(!setTimeOnProcces)
 3029              	 .loc 2 680 0
 3030 0158 3D4B     	 ldr r3,.L135+60
 3031 015a 1B78     	 ldrb r3,[r3]
 3032 015c 002B     	 cmp r3,#0
 3033 015e 01D1     	 bne .L125
 681:../main.c     **** 			{
 682:../main.c     **** 				UpdateLCD();
 3034              	 .loc 2 682 0
 3035 0160 FFF7FEFF 	 bl UpdateLCD
 3036              	.L125:
 683:../main.c     **** 			}
 684:../main.c     **** 			dataUpdated = 0;
 3037              	 .loc 2 684 0
 3038 0164 324B     	 ldr r3,.L135+28
 3039 0166 0022     	 movs r2,#0
 3040 0168 1A70     	 strb r2,[r3]
 3041              	.L124:
 685:../main.c     **** 		}
 686:../main.c     **** 
 687:../main.c     **** 		if(!XMC_GPIO_GetInput(BUTTON1))
 3042              	 .loc 2 687 0
 3043 016a 2A48     	 ldr r0,.L135
 3044 016c 0E21     	 movs r1,#14
 3045 016e FFF7FEFF 	 bl XMC_GPIO_GetInput
 3046 0172 0346     	 mov r3,r0
 3047 0174 002B     	 cmp r3,#0
 3048 0176 28D1     	 bne .L126
 688:../main.c     **** 		{
 689:../main.c     **** 			for(erhan2=0; erhan2<50000;erhan2++);
 3049              	 .loc 2 689 0
 3050 0178 0023     	 movs r3,#0
 3051 017a BB80     	 strh r3,[r7,#4]
 3052 017c 02E0     	 b .L127
 3053              	.L128:
 3054              	 .loc 2 689 0 is_stmt 0 discriminator 3
 3055 017e BB88     	 ldrh r3,[r7,#4]
 3056 0180 0133     	 adds r3,r3,#1
 3057 0182 BB80     	 strh r3,[r7,#4]
 3058              	.L127:
 3059              	 .loc 2 689 0 discriminator 1
 3060 0184 BB88     	 ldrh r3,[r7,#4]
 3061 0186 4CF24F32 	 movw r2,#49999
 3062 018a 9342     	 cmp r3,r2
 3063 018c F7D9     	 bls .L128
 690:../main.c     **** 			while(!XMC_GPIO_GetInput(BUTTON1));
 3064              	 .loc 2 690 0 is_stmt 1
 3065 018e 00BF     	 nop
 3066              	.L129:
 3067              	 .loc 2 690 0 is_stmt 0 discriminator 1
 3068 0190 2048     	 ldr r0,.L135
 3069 0192 0E21     	 movs r1,#14
 3070 0194 FFF7FEFF 	 bl XMC_GPIO_GetInput
 3071 0198 0346     	 mov r3,r0
 3072 019a 002B     	 cmp r3,#0
 3073 019c F8D0     	 beq .L129
 691:../main.c     **** 			setTimeMenu++;
 3074              	 .loc 2 691 0 is_stmt 1
 3075 019e 254B     	 ldr r3,.L135+32
 3076 01a0 1B78     	 ldrb r3,[r3]
 3077 01a2 0133     	 adds r3,r3,#1
 3078 01a4 DAB2     	 uxtb r2,r3
 3079 01a6 234B     	 ldr r3,.L135+32
 3080 01a8 1A70     	 strb r2,[r3]
 692:../main.c     **** 			setTimeMenu = setTimeMenu % SET_TIME_MENU_ITEMS_COUNT;
 3081              	 .loc 2 692 0
 3082 01aa 224B     	 ldr r3,.L135+32
 3083 01ac 1B78     	 ldrb r3,[r3]
 3084 01ae 03F00703 	 and r3,r3,#7
 3085 01b2 DAB2     	 uxtb r2,r3
 3086 01b4 1F4B     	 ldr r3,.L135+32
 3087 01b6 1A70     	 strb r2,[r3]
 693:../main.c     **** 			if(setTimeMenu)
 3088              	 .loc 2 693 0
 3089 01b8 1E4B     	 ldr r3,.L135+32
 3090 01ba 1B78     	 ldrb r3,[r3]
 3091 01bc 002B     	 cmp r3,#0
 3092 01be 04D0     	 beq .L126
 694:../main.c     **** 			{
 695:../main.c     **** 				setTimeOnProcces = 1;
 3093              	 .loc 2 695 0
 3094 01c0 234B     	 ldr r3,.L135+60
 3095 01c2 0122     	 movs r2,#1
 3096 01c4 1A70     	 strb r2,[r3]
 696:../main.c     **** 				setTimer();
 3097              	 .loc 2 696 0
 3098 01c6 FFF7FEFF 	 bl setTimer
 3099              	.L126:
 697:../main.c     **** 			}
 698:../main.c     **** 		}
 699:../main.c     **** 
 700:../main.c     **** 		if(!XMC_GPIO_GetInput(BUTTON2))
 3100              	 .loc 2 700 0
 3101 01ca 1248     	 ldr r0,.L135
 3102 01cc 0F21     	 movs r1,#15
 3103 01ce FFF7FEFF 	 bl XMC_GPIO_GetInput
 3104 01d2 0346     	 mov r3,r0
 3105 01d4 002B     	 cmp r3,#0
 3106 01d6 1BD1     	 bne .L130
 701:../main.c     **** 		{
 702:../main.c     **** 			for(erhan2=0; erhan2<50000;erhan2++);
 3107              	 .loc 2 702 0
 3108 01d8 0023     	 movs r3,#0
 3109 01da BB80     	 strh r3,[r7,#4]
 3110 01dc 02E0     	 b .L131
 3111              	.L132:
 3112              	 .loc 2 702 0 is_stmt 0 discriminator 3
 3113 01de BB88     	 ldrh r3,[r7,#4]
 3114 01e0 0133     	 adds r3,r3,#1
 3115 01e2 BB80     	 strh r3,[r7,#4]
 3116              	.L131:
 3117              	 .loc 2 702 0 discriminator 1
 3118 01e4 BB88     	 ldrh r3,[r7,#4]
 3119 01e6 4CF24F32 	 movw r2,#49999
 3120 01ea 9342     	 cmp r3,r2
 3121 01ec F7D9     	 bls .L132
 703:../main.c     **** 			while(!XMC_GPIO_GetInput(BUTTON2));
 3122              	 .loc 2 703 0 is_stmt 1
 3123 01ee 00BF     	 nop
 3124              	.L133:
 3125              	 .loc 2 703 0 is_stmt 0 discriminator 1
 3126 01f0 0848     	 ldr r0,.L135
 3127 01f2 0F21     	 movs r1,#15
 3128 01f4 FFF7FEFF 	 bl XMC_GPIO_GetInput
 3129 01f8 0346     	 mov r3,r0
 3130 01fa 002B     	 cmp r3,#0
 3131 01fc F8D0     	 beq .L133
 704:../main.c     **** 			if(setTimeMenu)
 3132              	 .loc 2 704 0 is_stmt 1
 3133 01fe 0D4B     	 ldr r3,.L135+32
 3134 0200 1B78     	 ldrb r3,[r3]
 3135 0202 002B     	 cmp r3,#0
 3136 0204 04D0     	 beq .L130
 705:../main.c     **** 			{
 706:../main.c     **** 				button2Pressed = 1;
 3137              	 .loc 2 706 0
 3138 0206 134B     	 ldr r3,.L135+64
 3139 0208 0122     	 movs r2,#1
 3140 020a 1A70     	 strb r2,[r3]
 707:../main.c     **** 				setTimer();
 3141              	 .loc 2 707 0
 3142 020c FFF7FEFF 	 bl setTimer
 3143              	.L130:
 708:../main.c     **** 			}
 709:../main.c     **** 		}
 710:../main.c     **** 
 711:../main.c     **** 	}
 3144              	 .loc 2 711 0
 3145 0210 7EE7     	 b .L134
 3146              	.L136:
 3147 0212 00BF     	 .align 2
 3148              	.L135:
 3149 0214 00810248 	 .word 1208123648
 3150 0218 F4000000 	 .word .LC14
 3151 021c 00000000 	 .word onProcess
 3152 0220 00000000 	 .word CAN_OBDII_LMO_01_Config
 3153 0224 00000000 	 .word flowControl
 3154 0228 04010000 	 .word .LC15
 3155 022c 00000000 	 .word smartdata
 3156 0230 00000000 	 .word dataUpdated
 3157 0234 00000000 	 .word setTimeMenu
 3158 0238 00000000 	 .word FatFs
 3159 023c 00000000 	 .word Fil
 3160 0240 14010000 	 .word .LC16
 3161 0244 20010000 	 .word .LC17
 3162 0248 00007A44 	 .word 1148846080
 3163 024c 00006145 	 .word 1163984896
 3164 0250 00000000 	 .word setTimeOnProcces
 3165 0254 00000000 	 .word button2Pressed
 3166              	 .cfi_endproc
 3167              	.LFE441:
 3169              	 .text
 3170              	.Letext0:
 3171              	 .file 3 "c:\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 3172              	 .file 4 "c:\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 3173              	 .file 5 "C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/CMSIS/Infineon/XMC4500_series/Include/XMC4500.h"
 3174              	 .file 6 "C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc/xmc4_gpio.h"
 3175              	 .file 7 "C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc/xmc_can.h"
 3176              	 .file 8 "C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Dave/Generated/GLOBAL_CAN/global_can.h"
 3177              	 .file 9 "C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Dave/Generated/CAN_NODE/can_node.h"
 3178              	 .file 10 "C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc/xmc_usic.h"
 3179              	 .file 11 "C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/XMCLib/inc/xmc_rtc.h"
 3180              	 .file 12 "C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Dave/Generated/FATFS/ff_Src/integer.h"
 3181              	 .file 13 "C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Dave/Generated/FATFS/ff_Src/ff.h"
 3182              	 .file 14 "C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Dave/Generated/DAVE.h"
 3183              	 .file 15 "../deffs.h"
 3184              	 .file 16 "C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/CMSIS/Include/core_cm4.h"
 3185              	 .file 17 "C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Libraries/CMSIS/Infineon/XMC4500_series/Include/system_XMC4500.h"
 3186              	 .file 18 "C:/Users/erhan/Desktop/smartlogger/design/firmware/xmc4500/smart_logger/smart_logger/Dave/Generated/CAN_NODE/can_node_extern.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
    {standard input}:20     .text.XMC_GPIO_SetOutputLow:00000000 $t
    {standard input}:24     .text.XMC_GPIO_SetOutputLow:00000000 XMC_GPIO_SetOutputLow
    {standard input}:68     .text.XMC_GPIO_ToggleOutput:00000000 $t
    {standard input}:72     .text.XMC_GPIO_ToggleOutput:00000000 XMC_GPIO_ToggleOutput
    {standard input}:115    .text.XMC_GPIO_GetInput:00000000 $t
    {standard input}:119    .text.XMC_GPIO_GetInput:00000000 XMC_GPIO_GetInput
    {standard input}:166    .bss.dataUpdated:00000000 dataUpdated
    {standard input}:167    .bss.dataUpdated:00000000 $d
    {standard input}:172    .bss.cellVoltagesUpdated:00000000 cellVoltagesUpdated
    {standard input}:173    .bss.cellVoltagesUpdated:00000000 $d
    {standard input}:179    .bss.sampleCounter:00000000 sampleCounter
    {standard input}:176    .bss.sampleCounter:00000000 $d
                            *COM*:00000238 FatFs
                            *COM*:0000022c Fil
                            *COM*:00000008 current_time
                            *COM*:00000008 set_time
    {standard input}:189    .bss.setTimeOnProcces:00000000 setTimeOnProcces
    {standard input}:190    .bss.setTimeOnProcces:00000000 $d
    {standard input}:195    .bss.setTimeMenu:00000000 setTimeMenu
    {standard input}:196    .bss.setTimeMenu:00000000 $d
    {standard input}:201    .bss.button2Pressed:00000000 button2Pressed
    {standard input}:202    .bss.button2Pressed:00000000 $d
    {standard input}:207    .bss.state:00000000 state
    {standard input}:208    .bss.state:00000000 $d
    {standard input}:213    .bss.stateBattVolt:00000000 stateBattVolt
    {standard input}:214    .bss.stateBattVolt:00000000 $d
    {standard input}:219    .bss.stateModuleTemps:00000000 stateModuleTemps
    {standard input}:220    .bss.stateModuleTemps:00000000 $d
    {standard input}:225    .bss.stateCellVoltages:00000000 stateCellVoltages
    {standard input}:226    .bss.stateCellVoltages:00000000 $d
    {standard input}:231    .bss.cellVoltagesFlowCounter:00000000 cellVoltagesFlowCounter
    {standard input}:232    .bss.cellVoltagesFlowCounter:00000000 $d
    {standard input}:237    .bss.onProcess:00000000 onProcess
    {standard input}:238    .bss.onProcess:00000000 $d
    {standard input}:243    .bss.samplingTimer:00000000 samplingTimer
    {standard input}:244    .bss.samplingTimer:00000000 $d
    {standard input}:249    .bss.canTimeoutTimerEnable:00000000 canTimeoutTimerEnable
    {standard input}:250    .bss.canTimeoutTimerEnable:00000000 $d
    {standard input}:255    .bss.canTimeoutCounter:00000000 canTimeoutCounter
    {standard input}:256    .bss.canTimeoutCounter:00000000 $d
    {standard input}:262    .data.flowControl:00000000 flowControl
    {standard input}:259    .data.flowControl:00000000 $d
    {standard input}:276    .data.reqBattAmp:00000000 reqBattAmp
    {standard input}:273    .data.reqBattAmp:00000000 $d
    {standard input}:290    .data.reqBattVolt:00000000 reqBattVolt
    {standard input}:287    .data.reqBattVolt:00000000 $d
    {standard input}:304    .data.reqModuleTemps:00000000 reqModuleTemps
    {standard input}:301    .data.reqModuleTemps:00000000 $d
    {standard input}:318    .data.reqCellVoltages:00000000 reqCellVoltages
    {standard input}:315    .data.reqCellVoltages:00000000 $d
                            *COM*:00000134 smartdata
    {standard input}:329    .text.CCU43_1_IRQHandler:00000000 $t
    {standard input}:334    .text.CCU43_1_IRQHandler:00000000 CCU43_1_IRQHandler
    {standard input}:447    .text.CCU43_1_IRQHandler:000000a4 $d
    {standard input}:461    .text.CAN0_1_IRQHandler:00000000 $t
    {standard input}:466    .text.CAN0_1_IRQHandler:00000000 CAN0_1_IRQHandler
    {standard input}:526    .text.CAN0_1_IRQHandler:00000060 $d
    {standard input}:534    .text.CAN0_0_IRQHandler:00000000 $t
    {standard input}:539    .text.CAN0_0_IRQHandler:00000000 CAN0_0_IRQHandler
    {standard input}:574    .text.CAN0_0_IRQHandler:00000028 $d
    {standard input}:580    .text.CAN0_0_IRQHandler:00000040 $t
    {standard input}:925    .text.CAN0_0_IRQHandler:00000298 $d
    {standard input}:943    .text.CAN0_0_IRQHandler:000002d8 $t
    {standard input}:1353   .text.CAN0_0_IRQHandler:00000570 $d
    {standard input}:1372   .rodata:00000000 $d
    {standard input}:1376   .text.writeToEndOfFile:00000000 $t
    {standard input}:1381   .text.writeToEndOfFile:00000000 writeToEndOfFile
    {standard input}:1465   .text.writeToEndOfFile:00000074 $d
    {standard input}:1481   .text.UpdateLCD:00000000 $t
    {standard input}:1486   .text.UpdateLCD:00000000 UpdateLCD
    {standard input}:1671   .text.UpdateLCD:000001a4 $d
    {standard input}:1706   .text.UpdateSDCard:00000000 $t
    {standard input}:1711   .text.UpdateSDCard:00000000 UpdateSDCard
    {standard input}:1949   .text.UpdateSDCard:000001f8 $d
    {standard input}:1966   .text.isLeapYear:00000000 $t
    {standard input}:1971   .text.isLeapYear:00000000 isLeapYear
    {standard input}:2046   .text.isLeapYear:0000005c $d
    {standard input}:2069   .text.setTimer:00000000 $t
    {standard input}:2074   .text.setTimer:00000000 setTimer
    {standard input}:2110   .text.setTimer:00000024 $d
    {standard input}:2118   .text.setTimer:00000044 $t
    {standard input}:2421   .text.setTimer:000002a8 $d
    {standard input}:2433   .text.setTimer:000002d0 $t
    {standard input}:2804   .text.setTimer:000005bc $d
    {standard input}:2829   .text.main:00000000 $t
    {standard input}:2834   .text.main:00000000 main
    {standard input}:3149   .text.main:00000214 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
CAN_NODE_MO_Init
CAN_OBDII_LMO_02_Config
__aeabi_i2d
__aeabi_ddiv
__aeabi_d2f
CAN_NODE_MO_Receive
CAN_OBDII
CAN_OBDII_LMO_03_Config
CAN_NODE_MO_UpdateData
CAN_NODE_MO_Transmit
CAN_OBDII_LMO_01_Config
f_mount
f_open
f_lseek
f_write
f_close
__aeabi_f2d
RTC_GetTime
LCDWriteCommand
sprintf
LCDCursorXY
LCDWriteString
strcpy
strcat
strlen
LCDWriteData
XMC_RTC_SetTime
DAVE_Init
XMC_GPIO_SetMode
LCDInit
