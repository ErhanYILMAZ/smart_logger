/**
* @file main.c
*
*  @date 28.2.19
*  @author Erhan YILMAZ
*  @brief Smart car OBDII Data logger application.
*  Based on https://github.com/MyLab-odyssey/ED_BMSdiag
*  Application code developed and tested on XMC4500 relax kit
*  Used for Smart EV car communication via OBDII can be evaluate for other usages.
*  Module codes generated by DAVE APPs. In case of any configuration change DAVE App modules should be configured from the UI of Dave app.
*/

#include <stdio.h>
#include <math.h>

#include <DAVE.h>                 //Declarations from DAVE Code Generation (includes SFR declaration)
#include "deffs.h"
#include "LCD_I2C.h"
void UpdateSDCard(void);



/**

 * @brief main() - Application entry point
 *
 * <b>Details of function</b><br>
 * This routine is the application entry point. It is invoked by the device startup code. It is responsible for
 * invoking the APP initialization dispatcher routine - DAVE_Init() and hosting the place-holder for user application
 * code.
 */



void TimerIRQHandler(void)
{
	if(!onProcess)
	{
		samplingTimer++;
		if(samplingTimer >= SAMPLING_PERIOD)
		{


			samplingTimer=0;
			CAN_OBDII_LMO_02_Config.mo_ptr->can_identifier = 0x200;
			CAN_OBDII_LMO_02_Config.mo_ptr->can_id_mask = 0x7FF;
			CAN_OBDII_LMO_02_Config.mo_ptr->can_data_length=8;
			CAN_NODE_MO_Init(&CAN_OBDII_LMO_02_Config);
			state = GET_VELOCITY;
			onProcess = 1;
			canTimeoutTimerEnable=1;


			/*
			samplingTimer=0;
			CAN_OBDII_LMO_02_Config.mo_ptr->can_identifier = 0x7ef;
			CAN_OBDII_LMO_02_Config.mo_ptr->can_id_mask = 0x7FF;
			CAN_OBDII_LMO_02_Config.mo_ptr->can_data_length=8;
			CAN_NODE_MO_Init(&CAN_OBDII_LMO_02_Config);
			CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,reqBattAmp);
			CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
			state = GET_BATT_AMP;
			onProcess = 1;
			canTimeoutTimerEnable=1;
			*/

		}
	}

	if(canTimeoutTimerEnable==1)
	{
		if(++canTimeoutCounter>=CAN_TIMEOUT)
		{
			canTimeoutCounter=0;
			state=IDLE;
			samplingTimer=0;
			onProcess=0;
			XMC_GPIO_ToggleOutput(LED1);
		}
	}

}

void CanM02RxRQHandler_2(void)
{
	CAN_NODE_MO_Receive(CAN_OBDII.lmobj_ptr[2]);		// get the received pacakge into message object.
	if(CAN_OBDII_LMO_03_Config.mo_ptr->can_identifier == 0x2D5)
	{
		smartdata.bms = ((CAN_OBDII_LMO_03_Config.mo_ptr->can_data_byte[4] & 0x03) * 256 + CAN_OBDII_LMO_03_Config.mo_ptr->can_data_byte[5])/10.0;
	}
}



void CanM02RxRQHandler(void)
{

	CAN_NODE_MO_Receive(CAN_OBDII.lmobj_ptr[1]);		// get the received pacakge into message object.
	canTimeoutCounter=0;

	switch(state)
	{
		case IDLE:
		break;

		case GET_VELOCITY:
			if(CAN_OBDII_LMO_02_Config.mo_ptr->can_identifier == 0x200)
			{
				smartdata.velocitiy = (CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[2] * 256 + CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[3])/18;
				CAN_OBDII_LMO_02_Config.mo_ptr->can_identifier = 0x7EF;
				CAN_OBDII_LMO_02_Config.mo_ptr->can_id_mask = 0x7FF;
				CAN_OBDII_LMO_02_Config.mo_ptr->can_data_length=8;
				CAN_NODE_MO_Init(&CAN_OBDII_LMO_02_Config);
				CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,reqBattAmp);
				CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
				state = GET_BATT_AMP;
			}
			else
			{
				state = IDLE;
				onProcess = 0;
			}
		break;

		case GET_BATT_AMP:
			if(CAN_OBDII_LMO_02_Config.mo_ptr->can_identifier == 0x7EF)
			{
				smartdata.battAmp = (float)((int16_t)(CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[4] * 256 + CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[5])/32.0F);
				CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,reqBattVolt);
				CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
				state = GET_BATT_VOLTAGE;
				stateBattVolt = BATT_VOLT_REQ_RESPONSE;
			}
			else
			{
				CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,reqBattAmp);
				CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
			}
		break;

		case GET_BATT_VOLTAGE:
			switch(stateBattVolt)
			{
				case BATT_VOLT_REQ_RESPONSE:
					if(CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[2] == 0x62)
					{
						CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,flowControl);
						CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
						stateBattVolt = BATT_VOLT_FLOW_RESPONSE;
					}
					else
					{
						CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,reqBattVolt);
						CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
					}
				break;

				case BATT_VOLT_FLOW_RESPONSE:
					if(CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[0] == 0x21)
					{
						smartdata.battVolt = (float)((CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[6] * 256 + CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[7])/64.0F);
						CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,reqModuleTemps);
						CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
						state = GET_MODULE_TEMPS;
						stateModuleTemps = MODULE_TEMPS_REQ_RESPONSE;
					}
					else
					{
						CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,reqBattVolt);
						CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
						stateBattVolt = BATT_VOLT_REQ_RESPONSE;
					}
				break;

				default:
				case BATT_VOLT_IDLE:
					onProcess=0;
					state=IDLE;
				break;
			}
		break;

		case GET_MODULE_TEMPS:

			switch(stateModuleTemps)
			{
				case MODULE_TEMPS_REQ_RESPONSE:
					if(CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[2] == 0x62)
					{
						smartdata.tempRawBytes[0]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[6];
						smartdata.tempRawBytes[1]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[5];
						smartdata.tempRawBytes[3]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[7];
						CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,flowControl);
						CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
						stateModuleTemps = MODULE_TEMPS_FLOW_RESPONSE;
					}
					else
					{
						CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,reqModuleTemps);
						CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
					}
				break;

				case MODULE_TEMPS_FLOW_RESPONSE:

					if(CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[0] == 0x21)
					{
						smartdata.tempRawBytes[2]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[1];
						smartdata.tempRawBytes[4]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[3];
						smartdata.tempRawBytes[5]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[2];
						smartdata.tempRawBytes[6]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[5];
						smartdata.tempRawBytes[7]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[4];
						smartdata.tempRawBytes[8]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[7];
						smartdata.tempRawBytes[9]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[6];
					}
					else if(CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[0] == 0x22)
					{
						smartdata.tempRawBytes[10]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[2];
						smartdata.tempRawBytes[11]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[1];
						smartdata.tempRawBytes[12]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[4];
						smartdata.tempRawBytes[13]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[3];
						smartdata.tempRawBytes[14]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[6];
						smartdata.tempRawBytes[15]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[5];
						smartdata.tempRawBytes[17]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[7];
					}
					else if(CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[0] == 0x23)
					{
						smartdata.tempRawBytes[16]=CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[1];
					}
					else if(CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[0] > 0x23 && CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[0] < 0x28)
					{
						// ignore these packages.
					}
					else if(CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[0] == 0x28)
					{
						CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,flowControl);
						CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
					}
					else if(CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[0] == 0x29)
					{
						uint8_t erhan = 0;
						for(erhan = 0; erhan < 9; erhan++)
						{
							smartdata.temps[erhan]=(float)(smartdata.tempRawBytes[2*erhan+1]*256 +smartdata.tempRawBytes[2*erhan])/64.0;
						}


						sampleCounter++;
						/*
						if(!(sampleCounter%CELL_VOLTAGES_SAMPLING_PERIOD))
						{
							CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,reqCellVoltages);
							CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
							state = GET_CELL_VOLTAGES;
							stateCellVoltages = CELL_VOLTAGES_REQ_RESPONSE;
						}
						else
						{
						*/
							XMC_GPIO_ToggleOutput(LED2);
							dataUpdated = 1;
							onProcess = 0;
							canTimeoutTimerEnable=0;
							state = IDLE;
						//}
					}
					else
					{
						///< Think about what to do here!!!
						/*
						CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,reqModuleTemps);
						CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
						stateModuleTemps = MODULE_TEMPS_REQ_RESPONSE;
						*/
					}
				break;

				default:
				case MODULE_TEMPS_IDLE:
					onProcess=0;
					state=IDLE;
				break;
			}
		break;

		case GET_CELL_VOLTAGES:
			switch(stateCellVoltages)
			{
				uint8_t erhan;
				case CELL_VOLTAGES_REQ_RESPONSE:
					if(CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[2] == 0x62)
					{
						smartdata.cellVotlagesBytes[0] = CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[5];
						smartdata.cellVotlagesBytes[1] = CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[6];
						smartdata.cellVotlagesBytes[2] = CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[7];
						CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,flowControl);
						CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
						stateCellVoltages = CELL_VOLTAGES_FLOW_CONTROL;
						cellVoltagesFlowCounter = 1;								// Set flow control count to 1.
					}
					else
					{
						CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,reqCellVoltages);
						CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
					}

				break;

				case CELL_VOLTAGES_FLOW_CONTROL:
					// Read flow control responses and save data bytes according to package indexes.

					erhan = (CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[0]-1) & 0x7;

					if(cellVoltagesFlowCounter <= CELL_VOLTAGES_DATA_FLOW_COUNT)
					{
						for(uint8_t erhan2=0; erhan2<7;erhan2++)
						{
							smartdata.cellVotlagesBytes[(cellVoltagesFlowCounter-1)*56 + 7*erhan + 3 + erhan2] = CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[erhan2+1];
						}
					}
					//////////////////////////////////////////////////////////////////////////////

					if(cellVoltagesFlowCounter >= CELL_VOLTAGES_FLOW_COUNT)
					{
						if(CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[0] == 0x29)
						{
							XMC_GPIO_ToggleOutput(LED2);
							dataUpdated = 1;
							onProcess = 0;
							canTimeoutTimerEnable=0;
							cellVoltagesUpdated = 1;
							state = IDLE;
						}
					}
					// Check if it is the time to sent next flow control package.
					if((CAN_OBDII_LMO_02_Config.mo_ptr->can_data_byte[0] % 0x8) == 0)
					{
						cellVoltagesFlowCounter++;	// Increase the flow counter variable.
						if(cellVoltagesFlowCounter <= CELL_VOLTAGES_FLOW_COUNT)	// Check if all flow control packages didn't send.
						{
							// Send next flow control package.
							CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,flowControl);
							CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
						}
						else	// If all flow control packages sent.
						{
							///< Think about what to do here!!!
							state = IDLE;
						}
					}
				break;

				case CELL_VOLTAGES_LAST_FLOW_PACKAGE:

				break;

				default:
				case CELL_VOLTAGES_IDLE:
					onProcess=0;
					state=IDLE;
				break;
			}
		break;
	}
}

BYTE writeToEndOfFile(FATFS* fs, FIL* fp, const TCHAR* path, const void *buff, UINT btw)
{
	UINT bw;
	if(f_mount(fs,"",0) == FR_OK)
	{
		if (f_open(fp, path, FA_OPEN_ALWAYS | FA_WRITE) == FR_OK)
		{
			if(f_lseek(fp, f_size(fp)) == FR_OK)
			{
				if(f_write(fp, buff, btw, &bw) == FR_OK)
				{
					if(f_close(fp) == FR_OK)
					{
						return 0;
					}
				}
			}
		}
	}
	f_close(fp);
	return 1;
}


void UpdateLCD(void)
{
	char temp[30];
	RTC_GetTime(&current_time);

	LCDWriteCommand(0x0E); // clear the screen
	sprintf(temp, "%03dV %03dA %03dkm/h", (int)smartdata.battVolt,(int)smartdata.battAmp,smartdata.velocitiy);
	LCDCursorXY(0, 0);
	LCDWriteString(temp);

	sprintf(temp,"%04d %04d %04d %02.1f",(int)(smartdata.temps[0]*10),(int)(smartdata.temps[1]*10),(int)(smartdata.temps[2]*10),smartdata.battPower);
	LCDCursorXY(1, 0);
	LCDWriteString(temp);

	sprintf(temp,"%04d %04d %04d %02.1f",(int)(smartdata.temps[3]*10),(int)(smartdata.temps[4]*10),(int)(smartdata.temps[5]*10),smartdata.battEnergy);
	LCDCursorXY(2, 0);
	LCDWriteString(temp);

	sprintf(temp,"%04d %04d %04d %05d",(int)(smartdata.temps[6]*10),(int)(smartdata.temps[7]*10),(int)(smartdata.temps[8]*10),(int)sampleCounter);
	LCDCursorXY(3, 0);
	LCDWriteString(temp);

	//XMC_RTC_GetTime(&current_time);
	//LCDCursorXY(3, 0);
	//sprintf(temp, "%04d/%02d/%02d %02d:%02d:%02d",current_time.year,current_time.month,current_time.days,current_time.hours,current_time.minutes,current_time.seconds);
	//LCDWriteString(temp);


	/*
	sprintf(temp, "%02d/%02d/%02d/%02d/%02d",current_time.days,current_time.month,current_time.hours,current_time.minutes,current_time.seconds);
	LCDWriteString(temp);
	LCDCursorXY(3, 0);
	sprintf(temp, "%03dV %03dA %03dkM", (int)smartdata.battVolt,(int)smartdata.battAmp,smartdata.velocitiy);
	LCDWriteString(temp);
	*/
}

void UpdateSDCard(void)
{
	char dateString[32];
	char timeString[32];
	char dataString[64];
	//char cellVoltagesString[5*93+20];
	char tempString[128];
	char tempFileNmaeString[64];
	char battFileNmaeString[64];
	//char cellVotlageFileNameString[64];
	char temp[16];
	char dataTimeString[128];
	uint8_t erhan;
	RTC_GetTime(&current_time);
	sprintf(dateString,"%04d %02d %02d",current_time.year,current_time.month,current_time.days);
	sprintf(timeString,"%02d %02d %02d:%05d:",current_time.hours,current_time.minutes,current_time.seconds,sampleCounter);

	sprintf(battFileNmaeString,"%s_data_erhan.txt",dateString);
	sprintf(dataString,"%03.2f:%03.2f:%03d:%03.2f\n",smartdata.battVolt,smartdata.battAmp,smartdata.velocitiy,smartdata.bms);
	strcpy(dataTimeString,timeString);
	strcat(dataTimeString,dataString);
	writeToEndOfFile(&FatFs, &Fil,battFileNmaeString, dataTimeString,strlen(dataTimeString));
/*
	if(cellVoltagesUpdated)
	{
		// Reverse MSB and LSB bytes in the cell voltages to represent it in 16bits and print on the CLI.
		for (uint8_t erhan2 = 0; erhan2 < CELL_VOLTAGES_DATA_FLOW_COUNT*28+2; erhan2++)
		{
			erhan = smartdata.cellVotlagesBytes[2*erhan2];
			smartdata.cellVotlagesBytes[2*erhan2] = smartdata.cellVotlagesBytes[2*erhan2+1];
			smartdata.cellVotlagesBytes[2*erhan2+1] = erhan;
		}

		sprintf(cellVotlageFileNameString,"%s_cell_voltages_erhan.txt",dateString);
		strcpy(cellVoltagesString,timeString);
		for(erhan = 0; erhan < CELL_COUNTS; erhan++)
		{
			sprintf(temp,"%04d:",smartdata.cellVoltages[erhan]);
			strcat(cellVoltagesString,temp);
		}
		strcat(cellVoltagesString,"\n");
		writeToEndOfFile(&FatFs, &Fil,cellVotlageFileNameString, cellVoltagesString,strlen(cellVoltagesString));
		cellVoltagesUpdated = 0;
	}
*/
	sprintf(tempFileNmaeString,"%s_temp_erhan.txt",dateString);
	strcpy(tempString,timeString);
	for (erhan = 0; erhan < 8; erhan++)
	{
		sprintf(temp,"%03.2f:",smartdata.temps[erhan]);
		strcat(tempString,temp);
	}
	sprintf(temp,"%03.2f",smartdata.temps[8]);
	strcat(tempString,temp);
	strcat(tempString,"\n");
	writeToEndOfFile(&FatFs, &Fil,tempFileNmaeString, tempString,strlen(tempString));

 }

uint8_t isLeapYear(uint32_t year)
{
	if (year%400 == 0) // Exactly divisible by 400 e.g. 1600, 2000
	  return 1;
	else if (year%100 == 0) // Exactly divisible by 100 and not by 400 e.g. 1900, 2100
	  return 0;
	else if (year%4 == 0) // Exactly divisible by 4 and neither by 100 nor 400 e.g. 2016, 2020
	  return 1;
	else // Not divisible by 4 or 100 or 400 e.g. 2017, 2018, 2019
	  return 0;
}

void setTimer(void)
{
	uint8_t monthsSize[12]={31,28,31,30,31,30,31,31,30,31,30,31};
	uint16_t erhan;
	char temp[26];
	switch(setTimeMenu)
	{
		case SET_TIME_IDLE:
		break;

		case SET_TIME_INIT:
			set_time.year = current_time.year;
			set_time.month = current_time.month;
			set_time.days = current_time.days;
			set_time.hours = current_time.hours;
			set_time.minutes = current_time.minutes;
			set_time.seconds = 0;

			LCDWriteCommand(0x01); // clear the screen
			LCDCursorXY(0, 0);
			sprintf(temp, "%04d/%02d/%02d %02d:%02d:%02d",set_time.year,set_time.days,set_time.month,set_time.hours,set_time.minutes,set_time.seconds);
			LCDWriteString(temp);
			LCDCursorXY(0, 4);
			LCDWriteCommand(0x10);
			setTimeMenu = YEAR;
		break;

		case YEAR:
			if(button2Pressed)
			{
				set_time.year++;
				if(set_time.year == 2100) set_time.year = 2000;
				button2Pressed = 0;
			}
			LCDCursorXY(0, 0);
			LCDWriteData((set_time.year/1000)+0x30);
			erhan = set_time.year % 1000;
			LCDWriteData((erhan/100) + 0x30);
			erhan = set_time.year % 100;
			LCDWriteData((erhan/10)+0x30);
			LCDWriteData((erhan%10)+0x30);
			LCDWriteCommand(0x10);
		break;

		case MONTH:
			if(button2Pressed)
			{
				if(++set_time.month>=13)
					set_time.month = 1;
				button2Pressed = 0;
			}
			LCDCursorXY(0, 5);
			LCDWriteData((set_time.month/10) + 0x30);
			LCDWriteData((set_time.month%10) + 0x30);
			LCDWriteCommand(0x10);
		break;

		case DAY:
			if(button2Pressed)
			{
				if(isLeapYear(set_time.year) && set_time.month==2)
				{
					if(++set_time.days >= 30)	//Feb is max 29 days
						set_time.days = 1;
				}
				else
				{
					if(set_time.days >= monthsSize[set_time.month-1])
						set_time.days = 1;
					else
						set_time.days++;
				}
				button2Pressed = 0;
			}
			LCDCursorXY(0, 8);
			LCDWriteData((set_time.days/10) + 0x30);
			LCDWriteData((set_time.days%10) + 0x30);
			LCDWriteCommand(0x10);
		break;

		case HOUR:
			if(button2Pressed)
			{
				set_time.hours++;
				set_time.hours = set_time.hours % 24;
				button2Pressed = 0;
			}
			LCDCursorXY(0, 11);
			LCDWriteData((set_time.hours/10) + 0x30);
			LCDWriteData((set_time.hours%10) + 0x30);
			LCDWriteCommand(0x10);
		break;

		case MINUTE:
			if(button2Pressed)
			{
				set_time.minutes++;
				set_time.minutes = set_time.minutes % 60;
				button2Pressed = 0;
			}
			LCDCursorXY(0, 14);
			LCDWriteData((set_time.minutes/10) + 0x30);
			LCDWriteData((set_time.minutes%10) + 0x30);
			LCDWriteCommand(0x10);
		break;

		case SET_OK:
		set_time.month--;
		set_time.days--;
		XMC_RTC_SetTime(&set_time);
		UpdateLCD();
		//XMC_RTC_GetTime(&current_time);
		//LCDCursorXY(1, 0);
		//sprintf(temp, "%04d/%02d/%02d %02d:%02d:%02d",current_time.year,current_time.month,current_time.days,current_time.hours,current_time.minutes,current_time.seconds);
		//LCDWriteString(temp);
		setTimeMenu=0;
		setTimeOnProcces = 0;
		break;
	}
}

int main(void)
{
	DAVE_STATUS_t status;
	uint8_t erhan;
	uint16_t erhan2;

	status = DAVE_Init();           /* Initialization of DAVE APPs  */
	if(status != DAVE_STATUS_SUCCESS)
	{
		/* Placeholder for error handler code. The while loop below can be replaced with an user error handler. */
		XMC_DEBUG("DAVE APPs initialization failed\n");

		while(1U)
		{

		}
	}


	// Set LED1, LED2 gpio pins.
	XMC_GPIO_SetMode(LED1, XMC_GPIO_MODE_OUTPUT_PUSH_PULL);
	XMC_GPIO_SetOutputLow(LED1);
	XMC_GPIO_SetMode(LED2, XMC_GPIO_MODE_OUTPUT_PUSH_PULL);
	XMC_GPIO_SetOutputLow(LED2);
	//XMC_GPIO_SetMode(BUTTON1,XMC_GPIO_MODE_INPUT_PULL_UP);
	///////////////////////////////////////////////////////
	LCDInit();
	LCDCursorXY(0, 0);
	LCDWriteString("Initializing...");
	onProcess = 1;
	CAN_OBDII_LMO_01_Config.mo_ptr->can_identifier = 0x7e7;
	CAN_OBDII_LMO_01_Config.mo_ptr->can_id_mask = 0x7FF;
	CAN_OBDII_LMO_01_Config.mo_ptr->can_data_length=8;
	CAN_NODE_MO_Init(&CAN_OBDII_LMO_01_Config);
	for(erhan=0; erhan<10; erhan++)
	{
		CAN_NODE_MO_UpdateData(&CAN_OBDII_LMO_01_Config,flowControl);
		CAN_NODE_MO_Transmit(&CAN_OBDII_LMO_01_Config);
		for(erhan2=0; erhan2<65000; erhan2++);
	}
	onProcess = 0;
	LCDCursorXY(0, 0);
	LCDWriteString("Initialized...");
	smartdata.velocitiy=0;
	smartdata.battAmp=0;
	smartdata.battVolt = 0;
	smartdata.battEnergy=0;
	smartdata.battPower=0;
	dataUpdated=0;
	setTimeMenu = 0;
	writeToEndOfFile(&FatFs, &Fil,"erhan.txt", "first of all Special thanks to Erhan YILMAZ!!!\r\n",sizeof("first of all special thanks to Erhan YILMAZ!!!\r\n"));

	UpdateLCD();
	while(1U)
	{
		if(dataUpdated)
		{
			smartdata.battPower = (smartdata.battVolt * smartdata.battAmp)/1000.0;
			smartdata.battEnergy = smartdata.battEnergy + (smartdata.battPower/3600.0f);
			UpdateSDCard();
			if(!setTimeOnProcces)
			{
				UpdateLCD();
			}
			dataUpdated = 0;
		}

		if(!XMC_GPIO_GetInput(BUTTON1))
		{
			for(erhan2=0; erhan2<50000;erhan2++);
			while(!XMC_GPIO_GetInput(BUTTON1));
			setTimeMenu++;
			setTimeMenu = setTimeMenu % SET_TIME_MENU_ITEMS_COUNT;
			if(setTimeMenu)
			{
				setTimeOnProcces = 1;
				setTimer();
			}
		}

		if(!XMC_GPIO_GetInput(BUTTON2))
		{
			for(erhan2=0; erhan2<50000;erhan2++);
			while(!XMC_GPIO_GetInput(BUTTON2));
			if(setTimeMenu)
			{
				button2Pressed = 1;
				setTimer();
			}
		}

	}
}
