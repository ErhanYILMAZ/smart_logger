/**
 * @file can_node.h
 * @date 2016-06-20
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * CAN_NODE v4.1.16 - Configures a Node and MO registers of MultiCAN module. It provides a run-time APIs to change the
 *                   node baud rate and to enable/disable Node and MO events.
 *
 * Copyright (c) 2015-2018, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-16:
 *     - Initial version<br>
 *
 * 2015-05-12:
 *     - CAN_NODE_EnableEvent() and CAN_NODE_ConfigBaudrate() APIs are included with additional arguments.<br>
 *     - New APIs are added: CAN_NODE_MO_ReceiveData(),CAN_NODE_MO_ClearStatus(), CAN_NODE_ClearStatus().<br>
 *
 * 2015-06-18:
 *     - LLD version check is removed.<br>
 *     - Version check added for XMCLib dependency.<br>
 *
 * 2015-06-30:
 *     - New APIs are added: CAN_NODE_Enable() and CAN_NODE_Disable() to enable and disable CAN node
 *         from participating CAN traffic. <br>
 *
 * 2016-06-20:
 *     - New API added: CAN_NODE_MO_UpdateID() to update the message object identifier.
 *
 * @endcond
 *
 */

/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/

#ifndef CAN_NODE_H
#define CAN_NODE_H

#include <xmc_can.h>
#include <xmc_gpio.h>
#include "../GLOBAL_CAN/global_can.h"
#include "can_node_conf.h"
#include <DAVE_common.h>

 /**********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/

#if (!((XMC_LIB_MAJOR_VERSION == 2U) && \
       (XMC_LIB_MINOR_VERSION >= 0U) && \
       (XMC_LIB_PATCH_VERSION >= 0U)))
#error "CAN_NODE requires XMC Peripheral Library v2.0.0 or higher"
#endif

 /**********************************************************************************************************************
 * ENUMS
 **********************************************************************************************************************/
/**
 * @ingroup CAN_NODE_enumerations
 * @{
 */

/**
 *  Enum to describe the possible status values, returned
 *  by CAN APIs.
 */
typedef enum CAN_NODE_STATUS
{
  CAN_NODE_STATUS_SUCCESS = 0, /**< APP success state */
  CAN_NODE_STATUS_FAILURE,  /**< Returned when unknown error occurred */
  CAN_NODE_STATUS_BUSY,      /**< CAN_NODE is busy and can not handle request*/
  CAN_NODE_STATUS_MO_NOT_ACCEPTABLE,/**< Message object type not allowed*/
  CAN_NODE_STATUS_MO_DISABLED  /**< Returned if Message object is disabled */
} CAN_NODE_STATUS_t;


/**
 * @}
 */

/**********************************************************************************************************************
* DATA STRUCTURES
**********************************************************************************************************************/

/**
 * @ingroup CAN_NODE_datastructures
 * @{
 */

/**
 * This is the data structure to hold the configured port and pin numbers for CAN_NODE.
 *
 */

typedef const struct CAN_NODE_GPIO
{
  XMC_GPIO_PORT_t  *const port; /**< Pointer to port hardware register to select for CAN communication */
  uint8_t  pin;    /**< Configured CAN Tx/Rx pin number */
} CAN_NODE_GPIO_t;

/**
 *    Node events service request structure for CAN_NODE.
 *    To enable the events user explicitly connect the signals to INTERUPT APP.
 */
typedef const struct CAN_NODE_SR
{
  uint8_t alert_event_sr;      /**< Alert event service request  */
  uint8_t lec_event_sr;        /**< LEC event service request  */
  uint8_t txok_event_sr;       /**< Transmit OK event service request  */
  uint8_t framecount_event_sr; /**< Frame count event service request  */
} CAN_NODE_SR_t;

/**
 *   Message object structure for CAN_NODE APP
 */
typedef struct CAN_NODE_LMO
{
  XMC_CAN_MO_t *mo_ptr;        /**< CAN message object pointer */
  uint8_t number;              /**< Consumed CAN message object number */
  uint8_t tx_sr;               /**< CAN message object transmit service request */
  uint8_t rx_sr;               /**< CAN message object receive service request */
  const bool tx_event_enable;  /**< GUI configured value for CAN message object transmit event check box  */
  const bool rx_event_enable;  /**< GUI configured value for CAN message object receive event check box  */
} CAN_NODE_LMO_t;

/**
 *  Initialization data structure for CAN_NODE APP
 */
typedef struct CAN_NODE
{
  GLOBAL_CAN_t *const global_ptr;                    /**< Global CAN pointer */
  XMC_CAN_NODE_t *const node_ptr;                    /**< Consumed CAN node pointer */
  XMC_CAN_NODE_NOMINAL_BIT_TIME_CONFIG_t *baudrate_config; /**< Pointer to bit time configuration structure */
  CAN_NODE_LMO_t *lmobj_ptr[32];                     /**< Array of pointer to logical message object structure*/
  CAN_NODE_SR_t *node_sr_ptr;                        /**< Node service request  */
  const CAN_NODE_GPIO_t    *const gpio_out;          /**< GPIO structure for CAN transmit pin  */
  const XMC_GPIO_CONFIG_t  *const gpio_out_config;   /**< GPIO configuration structure for CAN transmit pin */
  const CAN_NODE_GPIO_t    *const gpio_in;           /**< GPIO structure for CAN receive pin  */
  const XMC_GPIO_CONFIG_t  *const gpio_in_config;    /**< GPIO configuration structure for CAN receive pin */
  const XMC_CAN_NODE_RECEIVE_INPUT_t rx_signal;      /**< Possible input type for CAN receive pin */
  uint8_t node_num;                                  /**< Consumed CAN node number */
  uint8_t mo_count;                                  /**< GUI configured value Consumed CAN MO count for the node */
  bool lec_event_enable;                       /**< GUI configured value for LEC event check box  */
  bool txok_event_enable;                      /**< GUI configured value for transmit OK event check box */
  bool alert_event_enable;                     /**< GUI configured value for alert event check box  */
  bool framecount_event_enable;                /**< GUI configured value for frame count event check box  */
  bool loopback_enable;                        /**< GUI configured value for loop back enable check box  */

} CAN_NODE_t;

/**
 * @}
 */

/***********************************************************************************************************************
* API Prototypes
**********************************************************************************************************************/
/* Support for C++ codebase */
#ifdef __cplusplus
extern "C" {
#endif

/**
 * @ingroup CAN_NODE_apidoc
 * @{
 */

/**
 * @brief Function to read the CAN_NODE APP version.
 *
 * @return DAVE_APP_VERSION_t Structure that contains the members
 *         major, minor and patch values.
 *
 * \par<b>Description:</b><br>
 * The function can be used to check application software compatibility with a
 * specific version of the APP.
 *
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   int main(void)
 *   {
 *     DAVE_STATUS_t init_status;
 *     DAVE_APP_VERSION_t can_version;
 *     init_status = DAVE_Init();
 *     if (init_status == DAVE_STATUS_SUCCESS)
 *     {
 *       can_version = CAN_NODE_GetAppVersion();
 *       if ((can_version.major == 4U) &&
 *          (can_version.minor == 1U))
 *       {
 *         // Application code
 *       }
 *       else
 *       {
 *         // Probably, not the right version.
 *       }
 *     }
 *     // More code here
 *     while(1)
 *     {
 *
 *     }
 *
 *     return (1);
 *  }
 *  @endcode
 */
DAVE_APP_VERSION_t CAN_NODE_GetAppVersion(void);

/**
 * @brief Function to initialize the CAN node by configuring the baud rate,
 *        can bus type(External or internal) and message objects.
 *
 * @param handle  is a pointer pointing to APP data structure.@ref CAN_NODE_t
 * @return CAN_NODE_STATUS_t CAN_NODE_STATUS_SUCCESS: if the initialization succeeds.<BR>
 *                           CAN_NODE_STATUS_FAILURE  : for failure case.<BR>
 *
 * \par<b>Description:</b><br>
 * This function internally calls GLOBAL_CAN_Init() API to configure peripheral frequency
 * to enable CAN communication. API configures loop back mode or external CAN bus, message objects
 *  based on the settings and enables configured event flags and service request values.
 *
 * <BR>
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   int main(void)
 *   {
 *     CAN_NODE_STATUS_t init_status;
 *      // DAVE_Init() internally calls CAN_NODE_Init()
 *     init_status = CAN_NODE_Init(&CAN_NODE_0);
 *     if (init_status == CAN_NODE_STATUS_SUCCESS)
 *     {
 *
 *       // Application code
 *
 *     }
 *     else
 *     {
 *
 *      // Failed to initialize the CAN peripheral
 *     }
 *     // More code here
 *     while(1)
 *     {
 *
 *     }
 *
 *     return (1);
 *  }
 *  @endcode
 */
CAN_NODE_STATUS_t CAN_NODE_Init(const CAN_NODE_t *handle);

/**
 * @brief Function to initialize the CAN message object. It configures message type,
 *         message ID type, Identifier value, mask bits, required data length.<br>
 *         It also configures the transmit and receive events for the message object.<br>
 *
 * @param lmo_ptr is a handle with pointers to static and dynamic content of message object.@ref CAN_NODE_LMO_t.<br>
 * @return None.
 *
 * \par<b>Description:</b><br>
 *
 *  It configures message type to transmit / receive message object, message ID type to standard / extended MO,
 *         Identifier value, mask bits,required data length for the transmit message object.
 *  It also enables configured event flags for message objects.
 *  To achieve this functionality API calls XMC_CAN_MO_Config().
 * <BR>
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   int main(void)
 *   {
 *     DAVE_STATUS_t init_status;
 *     const CAN_NODE_t *HandlePtr1 = &CAN_NODE_0;
 *     XMC_CAN_MO_t *MO_Ptr;
 *
 *     MO_Ptr = HandlePtr1->lmobj_ptr[0]->mo_ptr;   //'0' refers to first message object configured
 *                                                   // for the selected can node
 *
 *     init_status = DAVE_Init(); //CAN_NODE_Init();
 *
 *     if (init_status == DAVE_STATUS_SUCCESS)
 *     {
 *
 *       //Application code.
 *
 *       MO_Ptr->can_mo_type = XMC_CAN_MO_TYPE_TRANSMSGOBJ;  //Configure message object type as transmit type
 *       MO_Ptr->can_id_mode = XMC_CAN_FRAME_TYPE_STANDARD_11BITS; //configure MO identifier type
 *       MO_Ptr->can_data_length = 8; // Configure CAN transmit MO data length field
 *       MO_Ptr->can_data[1] = 0xAAAA5555;  // Configure Higher 4 bytes of Data
 *       MO_Ptr->can_data[0] = 0xAAAA5555;  // Configure Lower 4 bytes of Data
 *       // Runtime change the MO configuration
 *       CAN_NODE_MO_Init(HandlePtr1->lmobj_ptr[0]);
 *
 *     }
 *     else
 *     {
 *       // CAN initialization failed
 *     }
 *     // More code here
 *     while(1)
 *     {
 *
 *     }
 *
 *     return (1);
 *  }
 *  @endcode
 */
void CAN_NODE_MO_Init(const CAN_NODE_LMO_t *lmo_ptr);

/**
 * @brief Function to configures the CAN bit time by using SJW, sample point and can frequency.<br>
 *
 * @param handle is a pointer pointing to APP data structure.@ref CAN_NODE_t
 * @param baudrate  is the required baud rate for the CAN node.
 * @param sample_point is the sample point for the bit time.<br>
 *        \b Range: 0% to 100% of the total bit time.<br>
 * @param sjw is the (synchronization jump width) time quanta for resynchronizations.<br>
 *
 * @return None.<BR>
 *
 * \par<b>Description:</b><br>
 *
 * This function configures the CAN node bit time by updating synchronous jump width,
 *      baud rate prescaler(BRP),sample point, divider mode, and time segment values to
 *      the node bit timing register(NBTR). To achieve this functionality
 *      API calls XMC_CAN_NODE_NominalBitTimeConfigure().
 * <BR>
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   int main(void)
 *   {
 *     const CAN_NODE_t *HandlePtr1= &CAN_NODE_0;
 *     DAVE_STATUS_t init_status;
 *     uint32_t new_baudrate = 1000000;  // in Hz
 *     uint16_t new_sampe_point = 80;
 *     uint8_t new_sjw = 2;
 *
 *     init_status = DAVE_Init();
 *     // DAVE_Init() internally calls CAN_NODE_Init()
 *     //CAN_NODE_Init() internally calls CAN_NODE_ConfigBaudrate()
 *     if (init_status == DAVE_STATUS_SUCCESS)
 *     {
 *       //  Application code ........
 *
 *       // For run time baud rate configuration change
 *       // Configure new baud rate to 1MHz
 *
 *       XMC_CAN_NODE_SetInitBit(HandlePtr1->node_ptr);
 *
 *       CAN_NODE_ConfigBaudrate(HandlePtr1, new_baudrate, new_sampe_point,new_sjw);
 *
 *       XMC_CAN_NODE_ResetInitBit(HandlePtr1->node_ptr);
 *
 *     }
 *     // More code here
 *     while(1)
 *     {
 *
 *     }
 *
 *     return (1);
 *  }
 *  @endcode
 */
void CAN_NODE_ConfigBaudrate(const CAN_NODE_t *handle, uint32_t baudrate, uint16_t sample_point, uint8_t sjw);


/**
 * @brief Function to enable the node events like node alert, LEC, Transfer OK, frame counter overflow.<br>
 * @param handle is a pointer pointing to APP data structure.@ref CAN_NODE_t<br>
 * @param  node_event is the required node event to enable. @ref XMC_CAN_NODE_EVENT_t <br>
 *         \b Note:  Multiple events can not be combined using \a OR operation.
 * @return None <BR>
 *
 * \par<b>Description:</b><br>
 * This function check the node event flags which are enabled through GUI. If the flags are configured,
 * then API enables the related CAN node events.
 * 1. XMC_CAN_NODE_EVENT_TX_INT
 * 2. XMC_CAN_NODE_EVENT_LEC
 * 3. XMC_CAN_NODE_EVENT_ALERT
 * 4. XMC_CAN_NODE_EVENT_CFCIE
 * This API enables the above events by configuring NCR register.
 * To achieve this functionality API calls XMC_CAN_NODE_EnableEvent().
 * <BR>
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   int main(void)
 *   {
 *     DAVE_STATUS_t init_status;
 *     const CAN_NODE_t *HandlePtr1 = &CAN_NODE_0;
 *
 *     init_status = DAVE_Init();
 *     //DAVE_Init();   internally calls CAN_NODE_Init()
 *     //CAN_NODE_Init() internally calls CAN_NODE_EnableEvent()
 *     if (init_status == DAVE_STATUS_SUCCESS)
 *     {
 *
 *       // Application code ..
 *
 *       // enable the events during run time....
 *       //  enable LEC event
 *        CAN_NODE_EnableEvent(HandlePtr1,XMC_CAN_NODE_EVENT_ALERT);
 *        // enable Alert event
 *        CAN_NODE_EnableEvent(HandlePtr1,XMC_CAN_NODE_EVENT_LEC);
 *        // enable Transmit OK event
 *        CAN_NODE_EnableEvent(HandlePtr1,XMC_CAN_NODE_EVENT_TX_INT);
 *        // enable CFCIE event
 *        CAN_NODE_EnableEvent(HandlePtr1,XMC_CAN_NODE_EVENT_CFCIE);
 *
 *        // Application code...
 *
 *
 *
 *        // disable the events by calling CAN_NODE_DisableEvent() API
 *
 *     }
 *     // More code here
 *     while (1)
 *     {
 *
 *     }
 *
 *     return (1);
 *  }
 *  @endcode
 */
void CAN_NODE_EnableEvent(const CAN_NODE_t *handle, const XMC_CAN_NODE_EVENT_t node_event);

/**
 * @brief Function to disable the selected node events like node alert, LEC, Transfer OK, frame counter overflow.
 * @param handle is a pointer pointing to APP data structure.@ref CAN_NODE_t.<br>
 * @param  node_event is the required node event to disable. @ref XMC_CAN_NODE_EVENT_t <br>
 *         \b Note:  Multiple events can not be combined using \a OR operation.
 * @return None.<BR>
 *
 * \par<b>Description:</b><br>
 *
 * This function disables the CAN node events. Using the API following node events can be disabled,
 * 1. XMC_CAN_NODE_EVENT_TX_INT
 * 2. XMC_CAN_NODE_EVENT_LEC
 * 3. XMC_CAN_NODE_EVENT_ALERT
 * 4. XMC_CAN_NODE_EVENT_CFCIE
 * To achieve this functionality API calls XMC_CAN_NODE_DisableEvent().
 * <BR>
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   int main(void)
 *   {
 *     DAVE_STATUS_t init_status;
 *     const CAN_NODE_t *HandlePtr1= &CAN_NODE_0;
 *
 *     init_status = DAVE_Init();
 *     if (init_status == DAVE_STATUS_SUCCESS)
 *     {
 *
 *        // Application code..
 *
 *        //  enable LEC event
 *        CAN_NODE_EnableEvent(HandlePtr1,XMC_CAN_NODE_EVENT_ALERT);
 *        // enable Alert event
 *        CAN_NODE_EnableEvent(HandlePtr1,XMC_CAN_NODE_EVENT_LEC);
 *        // enable Transmit OK event
 *        CAN_NODE_EnableEvent(HandlePtr1,XMC_CAN_NODE_EVENT_TX_INT);
 *        // enable CFCIE event
 *        CAN_NODE_EnableEvent(HandlePtr1,XMC_CAN_NODE_EVENT_CFCIE);
 *
 *        // Application code
 *
 *
 *        // For disabling LEC event
 *        CAN_NODE_DisableEvent(HandlePtr1,XMC_CAN_NODE_EVENT_ALERT);
 *        // For disabling Alert event
 *        CAN_NODE_DisableEvent(HandlePtr1,XMC_CAN_NODE_EVENT_LEC);
 *        // For disabling Transmit OK event
 *        CAN_NODE_DisableEvent(HandlePtr1,XMC_CAN_NODE_EVENT_TX_INT);
 *        // For disabling CFCIE event
 *        CAN_NODE_DisableEvent(HandlePtr1,XMC_CAN_NODE_EVENT_CFCIE);
 *
 *     }
 *     // More code here
 *     while(1)
 *     {
 *
 *     }
 *
 *     return (1);
 *  }
 *  @endcode
 */
void CAN_NODE_DisableEvent(const CAN_NODE_t *handle, const XMC_CAN_NODE_EVENT_t node_event);

/**
 * @brief Function to retrieve the current status of the can node.
 *        It contains error information as well as successfully transferred CAN frames status.
 * @param handle  is a pointer pointing to APP data structure.@ref CAN_NODE_t
 * @return status of type uint32_t.<BR>
 *
 * \par<b>Description:</b><br>
 * Status provides an overview about the current state of the respective CAN node,
 * comprising information about CAN transfers, CAN node status and error conditions.
 * It reads NSR (node status register)register.
 * To achieve this functionality API calls XMC_CAN_NODE_GetStatus().
 *
 * <BR>
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   int main(void)
 *   {
 *     DAVE_STATUS_t init_status;
 *     const CAN_NODE_t *HandlePtr1 = &CAN_NODE_0;
 *     uint32_t status;
 *
 *     init_status = DAVE_Init();
 *     if (init_status == DAVE_STATUS_SUCCESS)
 *     {
 *
 *       //Transmit MO data
 *       CAN_NODE_MO_Transmit(HandlePtr1->lmobj_ptr[0]);
 *
 *       status = CAN_NODE_GetStatus(HandlePtr1);
 *       if (status & XMC_CAN_NODE_STATUS_TX_OK)
 *       {
 *         //Message transmitted successfully
 *       }
 *       else if (status & XMC_CAN_NODE_STATUS_ALERT_WARNING)
 *       {
 *         // node alert warning event enabled
 *       }
 *       else if (status & XMC_CAN_NODE_STATUS_BUS_OFF)
 *       {
 *         //Bus off error
 *       }
 *
 *     }
 *     // More code here
 *     while(1)
 *     {
 *
 *     }
 *
 *     return (1);
 *  }
 *  @endcode
 */
uint32_t CAN_NODE_GetStatus(const CAN_NODE_t *handle);


/**
 * @brief Function to reset / clear the specific status of the can node.
 *        It contains error information as well as successfully transferred CAN frames status.<br>
 * @param can_node_status  is a node status enum. @ref XMC_CAN_NODE_STATUS_t <br>
 * @param handle  is a pointer pointing to APP data structure.@ref CAN_NODE_t <br>
 * @return none.<BR>
 *
 * \par<b>Description:</b><br>
 * Status provides an overview about the current state of the respective CAN node,
 * comprising information about CAN transfers, CAN node status and error conditions.
 * It reads NSR (node status register)register.
 * To achieve this functionality API calls XMC_CAN_NODE_GetStatus().
 *
 * <BR>
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   int main(void)
 *   {
 *     DAVE_STATUS_t init_status;
 *     const CAN_NODE_t *HandlePtr1 = &CAN_NODE_0;
 *     uint32_t status;
 *
 *     init_status = DAVE_Init();
 *     if (init_status == DAVE_STATUS_SUCCESS)
 *     {
 *
 *       //Transmit MO data
 *       CAN_NODE_MO_Transmit(HandlePtr1->lmobj_ptr[0]);
 *
 *       status = CAN_NODE_GetStatus(HandlePtr1);
 *       if (status & XMC_CAN_NODE_STATUS_TX_OK)
 *       {
 *         //Message transmitted successfully
 *         CAN_NODE_ClearStatus(HandlePtr1,XMC_CAN_NODE_STATUS_TX_OK);
 *         // Application code..
 *       }
 *       else if (status & XMC_CAN_NODE_STATUS_ALERT_WARNING)
 *       {
 *         // node alert warning event enabled
 *         CAN_NODE_ClearStatus(HandlePtr1,XMC_CAN_NODE_STATUS_ALERT_WARNING);
 *         // Application code..
 *       }
 *       else if (status & XMC_CAN_NODE_STATUS_BUS_OFF)
 *       {
 *         //Bus off error
 *       }
 *
 *     }
 *     // More code here
 *     while(1)
 *     {
 *
 *     }
 *
 *     return (1);
 *  }
 *  @endcode
 */
void CAN_NODE_ClearStatus(const CAN_NODE_t *handle, XMC_CAN_NODE_STATUS_t can_node_status);

/**
 * @brief Function to enable CAN node for participation in CAN traffic.<br>
 * @param handle is a pointer pointing to APP data structure.@ref CAN_NODE_t <br>
 * @return none.<BR>
 *
 * \par<b>Description:</b><br>
 * Enables the CAN node for participation in the CAN traffic by configuring NCR.INIT and NCR.CANDIS bits.
 * <BR>
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   int main(void)
 *   {
 *     DAVE_STATUS_t init_status;
 *     const CAN_NODE_t *HandlePtr1 = &CAN_NODE_0;
 *
 *     init_status = DAVE_Init();
 *     if (init_status == DAVE_STATUS_SUCCESS)
 *     {
 *
 *       // Application code..
 *
 *
 *       // Disable CAN node from participating in CAN traffic.
 *       CAN_NODE_Disable(HandlePtr1);
 *
 *       // Application code..
 *
 *
 *       // Enable CAN node for participating in CAN traffic.
 *       CAN_NODE_Enable(HandlePtr1);
 *
 *     }
 *     // More code here
 *     while(1)
 *     {
 *
 *     }
 *
 *     return (1);
 *  }
 *  @endcode
 */
__STATIC_INLINE void CAN_NODE_Enable(const CAN_NODE_t *handle)
{
  XMC_ASSERT("CAN_NODE_Enable: null pointer", handle != NULL);
  XMC_CAN_NODE_Enable(handle->node_ptr);
}

/**
 * @brief Function to disable CAN node from participating in CAN traffic.<br>
 * @param handle is a pointer pointing to APP data structure.@ref CAN_NODE_t <br>
 * @return none.<BR>
 *
 * \par<b>Description:</b><br>
 * Disables the CAN node from participating in the CAN traffic by configuring NCR.CANDIS bit.
 * <BR>
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   int main(void)
 *   {
 *     DAVE_STATUS_t init_status;
 *     const CAN_NODE_t *HandlePtr1 = &CAN_NODE_0;
 *
 *     init_status = DAVE_Init();
 *     if (init_status == DAVE_STATUS_SUCCESS)
 *     {
 *
 *       // Application code..
 *
 *
 *       // Disable CAN node from participating in CAN traffic.
 *       CAN_NODE_Disable(HandlePtr1);
 *
 *       // Application code..
 *
 *
 *       // Enable CAN node for participating in CAN traffic.
 *       CAN_NODE_Enable(HandlePtr1);
 *
 *     }
 *     // More code here
 *     while(1)
 *     {
 *
 *     }
 *
 *     return (1);
 *  }
 *  @endcode
 */
__STATIC_INLINE void CAN_NODE_Disable(const CAN_NODE_t *handle)
{
  XMC_ASSERT("CAN_NODE_Disable: null pointer", handle != NULL);
  XMC_CAN_NODE_Disable(handle->node_ptr);
}

/**
 * @brief Function to enable MO transmit event for the selected logical message object.
 *         It sets the TXIE bit of the MOFCR register.
 * @param can_lmo is a pointer to a logical message object structure.@ref CAN_NODE_LMO_t<br>
 * @return None.<BR>
 *
 * \par<b>Description:</b><br>
 *
 * This function to enable the MO transmit event for the selected logical message object.
 * It configures MOFCR register. To achieve this functionality API calls XMC_CAN_MO_EnableEvent().
 * <BR>
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   int main(void)
 *   {
 *     DAVE_STATUS_t init_status;
 *     const CAN_NODE_t *HandlePtr1 = &CAN_NODE_0;
 *
 *     init_status = DAVE_Init();
 *     if (init_status == DAVE_STATUS_SUCCESS)
 *     {
 *
 *       // Enable the transmit event for the selected message object.
 *       CAN_NODE_MO_EnableTxEvent(HandlePtr1->lmobj_ptr[0]);
 *
 *       //transmit data from the message object.
 *       CAN_NODE_MO_Transmit(HandlePtr1->lmobj_ptr[0]);
 *
 *       // Configure the interrupt APP and connect the transmit signal of the message object to NVIC node.
 *       //After the successful transmission of message object, transmit event will be generated.
 *       // Application code
 *
 *
 *     }
 *     // More code here
 *     while(1)
 *     {
 *
 *     }
 *
 *     return (1);
 *  }
 *  @endcode
 */
__STATIC_INLINE void CAN_NODE_MO_EnableTxEvent(const CAN_NODE_LMO_t *const can_lmo)
{
  XMC_ASSERT("CAN_NODE_MO_EnableTxEvent: null pointer", can_lmo != NULL);
  XMC_CAN_MO_EnableEvent(can_lmo->mo_ptr,XMC_CAN_MO_EVENT_TRANSMIT);
}

/**
 * @brief Function to enable MO receive event for the selected logical message object.
 *        It sets the RXIE bit of the MOFCR register. The event will be generated after
               reception of a CAN message.<br>
 * @param can_lmo is a pointer to a logical message object structure @ref CAN_NODE_LMO_t.
 * @return None.<BR>
 *
 * \par<b>Description:</b><br>
 *
 * This function to enable the MO receive event for the selected logical message object.
 * The event is generated after reception of a CAN message.
 * To achieve this functionality API calls XMC_CAN_MO_EnableEvent().
 * <BR>
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   int main(void)
 *   {
 *     DAVE_STATUS_t init_status;
 *     const CAN_NODE_t *HandlePtr1 = &CAN_NODE_0;
 *
 *     init_status = DAVE_Init();
 *     if (init_status == DAVE_STATUS_SUCCESS)
 *     {
 *
 *
 *       CAN_NODE_MO_EnableRxEvent(HandlePtr1->lmobj_ptr[0]);
 *
 *        // Application code
 *
 *
 *       // Configure the interrupt APP and connect the receive signal of the message object to NVIC node.
 *       //After the successful reception of message object, receive event will be generated.
 *
 *
 *     }
 *     // More code here
 *     while(1)
 *     {
 *
 *     }
 *
 *     return (1);
 *  }
 *  @endcode
 */

__STATIC_INLINE void CAN_NODE_MO_EnableRxEvent(const CAN_NODE_LMO_t *const can_lmo)
{
  XMC_ASSERT("CAN_NODE_MO_EnableRxEvent: null pointer", can_lmo != NULL);
  XMC_CAN_MO_EnableEvent(can_lmo->mo_ptr,XMC_CAN_MO_EVENT_RECEIVE);
}


/**
 * @brief Function to disable MO transmit event for the selected logical message object.
 *        If the transmit event already set, then it reset the event by configuring the MOFCR
 *        register bit field TXIE.<br>
 * @param can_lmo is a pointer to a logical message object structure @ref CAN_NODE_LMO_t.
 * @return None.<BR>
 *
 * \par<b>Description:</b><br>
 *
 * This function to disable the MO transmit event for the selected logical message object.
 * It configures MOFCR register. To achieve this functionality API calls XMC_CAN_MO_DisableEvent().
 * <BR>
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   int main(void)
 *   {
 *     DAVE_STATUS_t init_status;
 *     const CAN_NODE_t *HandlePtr1= &CAN_NODE_0;
 *
 *     init_status = DAVE_Init();
 *     if (init_status == DAVE_STATUS_SUCCESS)
 *     {
 *       // Enable the transmit event for the selected message object.
 *       CAN_NODE_MO_EnableTxEvent(HandlePtr1->lmobj_ptr[0]);
 *
 *       // Application code
 *
 *
 *       CAN_NODE_MO_DisableTxEvent(HandlePtr1->lmobj_ptr[0]);
 *
 *     }
 *     // More code here
 *     while(1)
 *     {
 *
 *     }
 *
 *     return (1);
 *  }
 *  @endcode
 */
__STATIC_INLINE void CAN_NODE_MO_DisableTxEvent(const CAN_NODE_LMO_t *const can_lmo)
{
  XMC_ASSERT("CAN_NODE_MO_DisableTxEvent: null pointer", can_lmo != NULL);
  XMC_CAN_MO_DisableEvent(can_lmo->mo_ptr,XMC_CAN_MO_EVENT_TRANSMIT);
}

/**
 * @brief Function to disable MO receive event for the selected logical message object.
 *        If the receive event already set, then it reset the event by configuring the MOFCR
 *        register bit field RXIE.<br>
 * @param can_lmo is a pointer to a logical message object structure @ref CAN_NODE_LMO_t.
 * @return None.<BR>
 *
 * \par<b>Description:</b><br>
 *
 * This function to disable the MO receive event for the selected MO.
 * It configures MOFCR register bit field RXIE. To achieve this functionality
 *  API calls XMC_CAN_MO_DisableEvent().
 * <BR>
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   int main(void)
 *   {
 *     DAVE_STATUS_t init_status;
 *     const CAN_NODE_t *HandlePtr1= &CAN_NODE_0;
 *
 *     init_status = DAVE_Init();
 *     if (init_status == DAVE_STATUS_SUCCESS)
 *     {
 *
 *       //Enable the receive event for the MO
 *        CAN_NODE_MO_EnableRxEvent(HandlePtr1->lmobj_ptr[0]);
 *
 *       // Application code
 *
 *       CAN_NODE_MO_DisableRxEvent(HandlePtr1->lmobj_ptr[0]);
 *
 *     }
 *     // More code here
 *     while(1)
 *     {
 *
 *     }
 *
 *     return (1);
 *  }
 *  @endcode
 */
__STATIC_INLINE void CAN_NODE_MO_DisableRxEvent(const CAN_NODE_LMO_t *const can_lmo)
{
  XMC_ASSERT("CAN_NODE_MO_DisableRxEvent: null pointer", can_lmo != NULL);
  XMC_CAN_MO_DisableEvent(can_lmo->mo_ptr,XMC_CAN_MO_EVENT_RECEIVE);
}

/**
 * @brief Function to update the data bytes for the selected logical message object. If the selected message
 *      object is of type transmit, then updates the data which passed as an argument to the message object.
 * @param lmo_ptr is a pointer to a logical message object structure of type CAN_NODE_LMO_t.
 * @param array_data is of type uint8_t* is a pointer to the data byte array to transmit.
 * @return status of type CAN_NODE_STATUS_t.<BR>
 *
 * \par<b>Description:</b><br>
 *
 * Function to update the data bytes for the selected transmit MO.
 * It configures data registers MODATAL and MODATAH with the new data.
 * To achieve this functionality API calls XMC_CAN_MO_UpdateData().
 * <BR>
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   int main(void)
 *   {
 *     DAVE_STATUS_t init_status;
 *     CAN_NODE_STATUS_t status;
 *     const CAN_NODE_t *HandlePtr1 = &CAN_NODE_0;
 *     uint8_t can_data_arr[8] = {0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08};
 *     uint8_t *array_data;
 *
 *     array_data = can_data_arr;
 *
 *     init_status = DAVE_Init();
 *     if (init_status == DAVE_STATUS_SUCCESS)
 *     {
 *       //  update data for the MO to transmit
 *       status = (CAN_NODE_STATUS_t)CAN_NODE_MO_UpdateData(HandlePtr1->lmobj_ptr[0],array_data);
 *
 *       if (status == CAN_NODE_STATUS_SUCCESS)
 *       {
 *         // message object data updated.
 *
 *         // transmit the data
 *         CAN_NODE_MO_Transmit(HandlePtr1->lmobj_ptr[0]);
 *       }
 *       else
 *       {
 *         // message object failed to update.
 *       }
 *
 *     }
 *     // More code here
 *     while(1)
 *     {
 *
 *     }
 *
 *     return (1);
 *  }
 *  @endcode
 */

CAN_NODE_STATUS_t CAN_NODE_MO_UpdateData(const CAN_NODE_LMO_t *const lmo_ptr, uint8_t *array_data);

/**
 * @brief Function to transmit the data from the configured message object.
 *        It verifies whether the transmission is ongoing on message object,and put a transmit
 *        request to transmit message object.
 * @param lmo_ptr is a pointer to a message object structure @ref CAN_NODE_LMO_t.
 * @return status of type CAN_NODE_STATUS_t.<BR>
 *
 * \par<b>Description:</b><br>
 *
 * This function to transmit the data for the selected MO by enabling the transmit request
 *      bit of MOCTR register. To achieve this functionality API calls XMC_CAN_MO_Transmit().
 * <BR>
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   int main(void)
 *   {
 *     DAVE_STATUS_t init_status;
 *     CAN_NODE_STATUS_t mo_tranmit_status;
 *     CAN_NODE_STATUS_t status;
 *     XMC_CAN_MO_t *MO_Ptr;
 *     const CAN_NODE_t *HandlePtr1 = &CAN_NODE_0;
 *     MO_Ptr = HandlePtr1->lmobj_ptr[0]->mo_ptr;
 *
 *     init_status = DAVE_Init();
 *     if (init_status == DAVE_STATUS_SUCCESS)
 *     {
 *       mo_tranmit_status = CAN_NODE_MO_Transmit(HandlePtr1->lmobj_ptr[0]);
 *       if (mo_tranmit_status == CAN_NODE_STATUS_SUCCESS)
 *       {
 *         //message object transmission success.
 *         // read the TXOK status bit
 *         status = CAN_NODE_MO_GetStatus(HandlePtr1->lmobj_ptr[0]);
 *
 *         if (status &  XMC_CAN_MO_STATUS_TX_PENDING);
 *         {
 *           //Clear the transmit OK flag
 *           XMC_CAN_MO_ResetStatus(MO_Ptr,XMC_CAN_MO_RESET_STATUS_TX_PENDING);
 *         }
 *       }
 *       else
 *       {
 *         // message object failed to transmit.
 *       }
 *
 *     }
 *     // More code here
 *     while(1)
 *     {
 *
 *     }
 *
 *     return (1);
 *  }
 *  @endcode
 */
CAN_NODE_STATUS_t CAN_NODE_MO_Transmit(const CAN_NODE_LMO_t *lmo_ptr);

/**
 * @brief Function to read the data bytes from the receive message object.
 *        It stores the received data to the message object structure. The API internally
 *        calls XMC_CAN_MO_Receive(). This API evaluates the selected message object
 *        is of type receive, then reads the data from MODATAL and MODATAH registers.
 * @param lmo_ptr is a pointer to a logical message object structure.
 * @return status of type CAN_NODE_STATUS_t.<BR>
 *
 * \par<b>Description:</b><br>
 *
 * This function to reads the received data for the selected MO.
 * It reads the data from MODATAL & MODATAH registers. MODATAL contains the lower 4 bytes of data.
 * MODATAH contains the higher 4 bytes of the data.
 * To achieve this functionality API calls XMC_CAN_MO_Receive().
 * <BR>
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   int main(void)
 *   {
 *     DAVE_STATUS_t init_status;
 *     CAN_NODE_STATUS_t receive_status;
 *     CAN_NODE_STATUS_t status;
 *     XMC_CAN_MO_t *MO_Ptr;
 *     const CAN_NODE_t *HandlePtr1 = &CAN_NODE_0;
 *     MO_Ptr = HandlePtr1->lmobj_ptr[0]->mo_ptr;
 *
 *     init_status = DAVE_Init();
 *     if (init_status == DAVE_STATUS_SUCCESS)
 *     {
 *
 *       // Application code
 *
 *       status = CAN_NODE_MO_GetStatus(HandlePtr1->lmobj_ptr[0]);
 *       //Check receive pending status
 *       if ( status & XMC_CAN_MO_STATUS_RX_PENDING)
 *       {
 *         // Clear the flag
 *         XMC_CAN_MO_ResetStatus(MO_Ptr,XMC_CAN_MO_RESET_STATUS_RX_PENDING);
 *         // Read the received Message object
 *         receive_status = CAN_NODE_MO_Receive(HandlePtr1->lmobj_ptr[0]);
 *         if (receive_status == CAN_NODE_STATUS_SUCCESS)
 *         {
 *           // message object receive success.
 *         }
 *         else
 *         {
 *           // message object failed to receive.
 *         }
 *
 *       }
 *    }
 *     // More code here
 *     while(1)
 *     {
 *
 *     }
 *
 *     return (1);
 *  }
 *  @endcode
 */
CAN_NODE_STATUS_t CAN_NODE_MO_Receive( CAN_NODE_LMO_t *lmo_ptr);

/**
 * @brief Function to read the data bytes from the receive message object.
 *        It stores the received data to the message object structure. The API internally
 *        calls XMC_CAN_MO_ReceiveData(). This API reads the data from MODATAL and MODATAH registers.
 * @param lmo_ptr is a pointer to a logical message object structure.
 * @return status of type CAN_NODE_STATUS_t.<BR>
 *
 * \par<b>Description:</b><br>
 *
 * This function to reads the received data for the selected MO.
 * It reads the data from MODATAL & MODATAH registers. MODATAL contains the lower 4 bytes of data.
 * MODATAH contains the higher 4 bytes of the data.
 * To achieve this functionality API calls XMC_CAN_MO_ReceiveData().
 * <BR>
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   int main(void)
 *   {
 *     DAVE_STATUS_t init_status;
 *     CAN_NODE_STATUS_t receive_status;
 *     CAN_NODE_STATUS_t status;
 *     XMC_CAN_MO_t *MO_Ptr;
 *     const CAN_NODE_t *HandlePtr1 = &CAN_NODE_0;
 *     MO_Ptr = HandlePtr1->lmobj_ptr[0]->mo_ptr;
 *
 *     init_status = DAVE_Init();
 *     if (init_status == DAVE_STATUS_SUCCESS)
 *     {
 *
 *       // Application code
 *
 *       status = CAN_NODE_MO_GetStatus(HandlePtr1->lmobj_ptr[0]);
 *       //Check receive pending status
 *       if ( status & XMC_CAN_MO_STATUS_RX_PENDING)
 *       {
 *         // Clear the flag
 *         XMC_CAN_MO_ResetStatus(MO_Ptr,XMC_CAN_MO_RESET_STATUS_RX_PENDING);
 *         // Read the received Message object
 *         receive_status = CAN_NODE_MO_ReceiveData(HandlePtr1->lmobj_ptr[0]);
 *         if (receive_status == CAN_NODE_STATUS_SUCCESS)
 *         {
 *           // message object receive success.
 *         }
 *         else
 *         {
 *           // message object failed to receive.
 *         }
 *
 *       }
 *    }
 *     // More code here
 *     while(1)
 *     {
 *
 *     }
 *
 *     return (1);
 *  }
 *  @endcode
 */
CAN_NODE_STATUS_t CAN_NODE_MO_ReceiveData( CAN_NODE_LMO_t *lmo_ptr);

/**
 * @brief Function to read the current status for the can message object. Which includes information
 *        like message object transfer status, receive/transmit pending and the list number to which
 *         the message object is assigned.
 * @param lmo_ptr is a pointer to a logical message object structure.
 * @return status of type uint32_t.<BR>
 *
 * \par<b>Description:</b><br>
 *
 * This function to read the status information for the selected MO. Based on the status information further
 *  processing on the message object is made. It reads MOSTAT register.
 *  To achieve this functionality API calls XMC_CAN_MO_GetStatus().
 * <BR>
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   int main(void)
 *   {
 *     DAVE_STATUS_t init_status;
 *     uint32_t status;
 *     CAN_NODE_LMO_t *MO_Ptr;
 *     const CAN_NODE_t *HandlePtr1 = &CAN_NODE_0;
 *     MO_Ptr = HandlePtr1->lmobj_ptr[0];
 *     init_status = DAVE_Init();
 *     if (init_status == DAVE_STATUS_SUCCESS)
 *     {
 *
 *       status =  CAN_NODE_MO_GetStatus(CAN_NODE_0.lmobj_ptr[0]);
 *       // For receive status
 *       if ( status & XMC_CAN_MO_STATUS_RX_PENDING)
 *       {
 *         // clear the RXOK bit using the below API
 *         CAN_NODE_MO_ClearStatus(MO_Ptr,XMC_CAN_MO_RESET_STATUS_RX_PENDING);
 *       }
 *       //for transmit status
 *       if (status &  XMC_CAN_MO_STATUS_TX_PENDING)
 *       {
 *         // clear the TXOK bit using the below API
 *         CAN_NODE_MO_ClearStatus(MO_Ptr,XMC_CAN_MO_RESET_STATUS_TX_PENDING);
 *       }
 *
 *     }
 *     // More code here
 *     while(1)
 *     {
 *
 *     }
 *
 *     return (1);
 *  }
 *  @endcode
 */
uint32_t CAN_NODE_MO_GetStatus(const CAN_NODE_LMO_t *lmo_ptr);

/**
 * @brief Function to clear the current status for the can message object like,
 *  message object transfer status, receive/transmit pending and the list number to which
 *         the message object is assigned.
 * @param lmo_ptr is a pointer to a logical message object structure.
 * @param mask is a Message object clear status selection.
 *             \b Range: Use type @ref XMC_CAN_MO_RESET_STATUS_t. Multiple events can be
 *                    combined using \a OR operation.
 * @return None.<BR>
 *
 * \par<b>Description:</b><br>
 *
 * This function to read the status information for the selected MO. Based on the status information further
 *  processing on the message object is made. It reads MOSTAT register.
 *  To achieve this functionality API calls XMC_CAN_MO_GetStatus().
 * <BR>
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   int main(void)
 *   {
 *     DAVE_STATUS_t init_status;
 *     uint32_t status;
 *     CAN_NODE_LMO_t *MO_Ptr;
 *     const CAN_NODE_t *HandlePtr1 = &CAN_NODE_0;
 *     MO_Ptr = HandlePtr1->lmobj_ptr[0];
 *     init_status = DAVE_Init();
 *     if (init_status == DAVE_STATUS_SUCCESS)
 *     {
 *
 *       status =  CAN_NODE_MO_GetStatus(CAN_NODE_0.lmobj_ptr[0]);
 *       // For receive status
 *       if ( status & XMC_CAN_MO_STATUS_RX_PENDING)
 *       {
 *         // clear the RXOK bit using the below API
 *         CAN_NODE_MO_ClearStatus(MO_Ptr,XMC_CAN_MO_RESET_STATUS_RX_PENDING);
 *       }
 *       //for transmit status
 *       if (status &  XMC_CAN_MO_STATUS_TX_PENDING)
 *       {
 *         // clear the TXOK bit using the below API
 *         CAN_NODE_MO_ClearStatus(MO_Ptr,XMC_CAN_MO_RESET_STATUS_TX_PENDING);
 *       }
 *
 *     }
 *     // More code here
 *     while(1)
 *     {
 *
 *     }
 *
 *     return (1);
 *  }
 *  @endcode
 */
void CAN_NODE_MO_ClearStatus(const CAN_NODE_LMO_t *lmo_ptr, const uint32_t mask);

/**
 * @brief Function to update the mesasage object identifier.<br>
 *
 * @param lmo_ptr Handle with pointers to static and dynamic content of message object.@ref CAN_NODE_LMO_t.<br>
 * @param id      Message object identifier number.<br>
 * @return None.
 *
 * \par<b>Description:</b><br>
 *
 *  It configures mesasage object identifier for the transmit message object.
 * <BR>
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   int main(void)
 *   {
 *     DAVE_STATUS_t init_status;
 *
 *     init_status = DAVE_Init(); //CAN_NODE_Init();
 *
 *     if (init_status == DAVE_STATUS_SUCCESS)
 *     {
 *       //Application code.
 *       CAN_NODE_MO_UpdateID(CAN_NODE_0.lmobj_ptr[0], 1U);
 *     }
 *     
 *     // More code here
 *     while(1)
 *     {
 *
 *     }
 *
 *     return (1);
 *  }
 *  @endcode
 */
__STATIC_INLINE void CAN_NODE_MO_UpdateID(const CAN_NODE_LMO_t * const lmo_ptr, const uint32_t id)
{
  XMC_CAN_MO_SetIdentifier(lmo_ptr->mo_ptr, id);
 }

/**
 * @}
 */

#include"can_node_extern.h"
/* Support for C++ codebase */
#ifdef __cplusplus
}
#endif   

#endif /* End of _CAN_NODE_H */

